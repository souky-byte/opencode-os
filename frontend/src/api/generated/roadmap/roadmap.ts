/**
 * Generated by orval v7.17.2 üç∫
 * Do not edit manually.
 * OpenCode Studio API
 * API for OpenCode Studio - AI-powered development platform
 * OpenAPI spec version: 0.1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  ConvertToTaskResponse,
  GenerateRoadmapRequest,
  RoadmapFeature,
  RoadmapGenerationStatus,
  RoadmapResponse,
  UpdateFeatureRequest
} from '.././model';

import { customFetch } from '../../../lib/api-fetcher';


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



export type getRoadmapResponse200 = {
  data: RoadmapResponse
  status: 200
}
    
export type getRoadmapResponseSuccess = (getRoadmapResponse200) & {
  headers: Headers;
};
;

export type getRoadmapResponse = (getRoadmapResponseSuccess)

export const getGetRoadmapUrl = () => {


  

  return `/api/roadmap`
}

export const getRoadmap = async ( options?: RequestInit): Promise<getRoadmapResponse> => {
  
  return customFetch<getRoadmapResponse>(getGetRoadmapUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetRoadmapQueryKey = () => {
    return [
    `/api/roadmap`
    ] as const;
    }

    
export const getGetRoadmapQueryOptions = <TData = Awaited<ReturnType<typeof getRoadmap>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoadmap>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRoadmapQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRoadmap>>> = ({ signal }) => getRoadmap({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRoadmap>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRoadmapQueryResult = NonNullable<Awaited<ReturnType<typeof getRoadmap>>>
export type GetRoadmapQueryError = unknown


export function useGetRoadmap<TData = Awaited<ReturnType<typeof getRoadmap>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoadmap>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRoadmap>>,
          TError,
          Awaited<ReturnType<typeof getRoadmap>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRoadmap<TData = Awaited<ReturnType<typeof getRoadmap>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoadmap>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRoadmap>>,
          TError,
          Awaited<ReturnType<typeof getRoadmap>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRoadmap<TData = Awaited<ReturnType<typeof getRoadmap>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoadmap>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetRoadmap<TData = Awaited<ReturnType<typeof getRoadmap>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoadmap>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRoadmapQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export type deleteRoadmapResponse204 = {
  data: void
  status: 204
}

export type deleteRoadmapResponse404 = {
  data: void
  status: 404
}
    
export type deleteRoadmapResponseSuccess = (deleteRoadmapResponse204) & {
  headers: Headers;
};
export type deleteRoadmapResponseError = (deleteRoadmapResponse404) & {
  headers: Headers;
};

export type deleteRoadmapResponse = (deleteRoadmapResponseSuccess | deleteRoadmapResponseError)

export const getDeleteRoadmapUrl = () => {


  

  return `/api/roadmap`
}

export const deleteRoadmap = async ( options?: RequestInit): Promise<deleteRoadmapResponse> => {
  
  return customFetch<deleteRoadmapResponse>(getDeleteRoadmapUrl(),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}




export const getDeleteRoadmapMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteRoadmap>>, TError,void, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteRoadmap>>, TError,void, TContext> => {

const mutationKey = ['deleteRoadmap'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteRoadmap>>, void> = () => {
          

          return  deleteRoadmap(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteRoadmapMutationResult = NonNullable<Awaited<ReturnType<typeof deleteRoadmap>>>
    
    export type DeleteRoadmapMutationError = void

    export const useDeleteRoadmap = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteRoadmap>>, TError,void, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteRoadmap>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getDeleteRoadmapMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    export type getFeatureResponse200 = {
  data: RoadmapFeature
  status: 200
}

export type getFeatureResponse404 = {
  data: void
  status: 404
}
    
export type getFeatureResponseSuccess = (getFeatureResponse200) & {
  headers: Headers;
};
export type getFeatureResponseError = (getFeatureResponse404) & {
  headers: Headers;
};

export type getFeatureResponse = (getFeatureResponseSuccess | getFeatureResponseError)

export const getGetFeatureUrl = (featureId: string,) => {


  

  return `/api/roadmap/features/${featureId}`
}

export const getFeature = async (featureId: string, options?: RequestInit): Promise<getFeatureResponse> => {
  
  return customFetch<getFeatureResponse>(getGetFeatureUrl(featureId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetFeatureQueryKey = (featureId?: string,) => {
    return [
    `/api/roadmap/features/${featureId}`
    ] as const;
    }

    
export const getGetFeatureQueryOptions = <TData = Awaited<ReturnType<typeof getFeature>>, TError = void>(featureId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFeature>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetFeatureQueryKey(featureId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getFeature>>> = ({ signal }) => getFeature(featureId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(featureId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getFeature>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetFeatureQueryResult = NonNullable<Awaited<ReturnType<typeof getFeature>>>
export type GetFeatureQueryError = void


export function useGetFeature<TData = Awaited<ReturnType<typeof getFeature>>, TError = void>(
 featureId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFeature>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFeature>>,
          TError,
          Awaited<ReturnType<typeof getFeature>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetFeature<TData = Awaited<ReturnType<typeof getFeature>>, TError = void>(
 featureId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFeature>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFeature>>,
          TError,
          Awaited<ReturnType<typeof getFeature>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetFeature<TData = Awaited<ReturnType<typeof getFeature>>, TError = void>(
 featureId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFeature>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetFeature<TData = Awaited<ReturnType<typeof getFeature>>, TError = void>(
 featureId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFeature>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetFeatureQueryOptions(featureId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export type updateFeatureResponse200 = {
  data: RoadmapFeature
  status: 200
}

export type updateFeatureResponse404 = {
  data: void
  status: 404
}
    
export type updateFeatureResponseSuccess = (updateFeatureResponse200) & {
  headers: Headers;
};
export type updateFeatureResponseError = (updateFeatureResponse404) & {
  headers: Headers;
};

export type updateFeatureResponse = (updateFeatureResponseSuccess | updateFeatureResponseError)

export const getUpdateFeatureUrl = (featureId: string,) => {


  

  return `/api/roadmap/features/${featureId}`
}

export const updateFeature = async (featureId: string,
    updateFeatureRequest: UpdateFeatureRequest, options?: RequestInit): Promise<updateFeatureResponse> => {
  
  return customFetch<updateFeatureResponse>(getUpdateFeatureUrl(featureId),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      updateFeatureRequest,)
  }
);}




export const getUpdateFeatureMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateFeature>>, TError,{featureId: string;data: UpdateFeatureRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof updateFeature>>, TError,{featureId: string;data: UpdateFeatureRequest}, TContext> => {

const mutationKey = ['updateFeature'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateFeature>>, {featureId: string;data: UpdateFeatureRequest}> = (props) => {
          const {featureId,data} = props ?? {};

          return  updateFeature(featureId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateFeatureMutationResult = NonNullable<Awaited<ReturnType<typeof updateFeature>>>
    export type UpdateFeatureMutationBody = UpdateFeatureRequest
    export type UpdateFeatureMutationError = void

    export const useUpdateFeature = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateFeature>>, TError,{featureId: string;data: UpdateFeatureRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateFeature>>,
        TError,
        {featureId: string;data: UpdateFeatureRequest},
        TContext
      > => {

      const mutationOptions = getUpdateFeatureMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    export type convertFeatureToTaskResponse201 = {
  data: ConvertToTaskResponse
  status: 201
}

export type convertFeatureToTaskResponse400 = {
  data: void
  status: 400
}

export type convertFeatureToTaskResponse404 = {
  data: void
  status: 404
}
    
export type convertFeatureToTaskResponseSuccess = (convertFeatureToTaskResponse201) & {
  headers: Headers;
};
export type convertFeatureToTaskResponseError = (convertFeatureToTaskResponse400 | convertFeatureToTaskResponse404) & {
  headers: Headers;
};

export type convertFeatureToTaskResponse = (convertFeatureToTaskResponseSuccess | convertFeatureToTaskResponseError)

export const getConvertFeatureToTaskUrl = (featureId: string,) => {


  

  return `/api/roadmap/features/${featureId}/convert-to-task`
}

export const convertFeatureToTask = async (featureId: string, options?: RequestInit): Promise<convertFeatureToTaskResponse> => {
  
  return customFetch<convertFeatureToTaskResponse>(getConvertFeatureToTaskUrl(featureId),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}




export const getConvertFeatureToTaskMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof convertFeatureToTask>>, TError,{featureId: string}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof convertFeatureToTask>>, TError,{featureId: string}, TContext> => {

const mutationKey = ['convertFeatureToTask'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof convertFeatureToTask>>, {featureId: string}> = (props) => {
          const {featureId} = props ?? {};

          return  convertFeatureToTask(featureId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ConvertFeatureToTaskMutationResult = NonNullable<Awaited<ReturnType<typeof convertFeatureToTask>>>
    
    export type ConvertFeatureToTaskMutationError = void

    export const useConvertFeatureToTask = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof convertFeatureToTask>>, TError,{featureId: string}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof convertFeatureToTask>>,
        TError,
        {featureId: string},
        TContext
      > => {

      const mutationOptions = getConvertFeatureToTaskMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    export type generateRoadmapResponse202 = {
  data: void
  status: 202
}

export type generateRoadmapResponse400 = {
  data: void
  status: 400
}

export type generateRoadmapResponse500 = {
  data: void
  status: 500
}
    
export type generateRoadmapResponseSuccess = (generateRoadmapResponse202) & {
  headers: Headers;
};
export type generateRoadmapResponseError = (generateRoadmapResponse400 | generateRoadmapResponse500) & {
  headers: Headers;
};

export type generateRoadmapResponse = (generateRoadmapResponseSuccess | generateRoadmapResponseError)

export const getGenerateRoadmapUrl = () => {


  

  return `/api/roadmap/generate`
}

export const generateRoadmap = async (generateRoadmapRequest: GenerateRoadmapRequest, options?: RequestInit): Promise<generateRoadmapResponse> => {
  
  return customFetch<generateRoadmapResponse>(getGenerateRoadmapUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      generateRoadmapRequest,)
  }
);}




export const getGenerateRoadmapMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof generateRoadmap>>, TError,{data: GenerateRoadmapRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof generateRoadmap>>, TError,{data: GenerateRoadmapRequest}, TContext> => {

const mutationKey = ['generateRoadmap'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof generateRoadmap>>, {data: GenerateRoadmapRequest}> = (props) => {
          const {data} = props ?? {};

          return  generateRoadmap(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type GenerateRoadmapMutationResult = NonNullable<Awaited<ReturnType<typeof generateRoadmap>>>
    export type GenerateRoadmapMutationBody = GenerateRoadmapRequest
    export type GenerateRoadmapMutationError = void

    export const useGenerateRoadmap = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof generateRoadmap>>, TError,{data: GenerateRoadmapRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof generateRoadmap>>,
        TError,
        {data: GenerateRoadmapRequest},
        TContext
      > => {

      const mutationOptions = getGenerateRoadmapMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    export type getGenerationStatusResponse200 = {
  data: RoadmapGenerationStatus
  status: 200
}
    
export type getGenerationStatusResponseSuccess = (getGenerationStatusResponse200) & {
  headers: Headers;
};
;

export type getGenerationStatusResponse = (getGenerationStatusResponseSuccess)

export const getGetGenerationStatusUrl = () => {


  

  return `/api/roadmap/status`
}

export const getGenerationStatus = async ( options?: RequestInit): Promise<getGenerationStatusResponse> => {
  
  return customFetch<getGenerationStatusResponse>(getGetGenerationStatusUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetGenerationStatusQueryKey = () => {
    return [
    `/api/roadmap/status`
    ] as const;
    }

    
export const getGetGenerationStatusQueryOptions = <TData = Awaited<ReturnType<typeof getGenerationStatus>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGenerationStatus>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetGenerationStatusQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getGenerationStatus>>> = ({ signal }) => getGenerationStatus({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getGenerationStatus>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetGenerationStatusQueryResult = NonNullable<Awaited<ReturnType<typeof getGenerationStatus>>>
export type GetGenerationStatusQueryError = unknown


export function useGetGenerationStatus<TData = Awaited<ReturnType<typeof getGenerationStatus>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGenerationStatus>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGenerationStatus>>,
          TError,
          Awaited<ReturnType<typeof getGenerationStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetGenerationStatus<TData = Awaited<ReturnType<typeof getGenerationStatus>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGenerationStatus>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGenerationStatus>>,
          TError,
          Awaited<ReturnType<typeof getGenerationStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetGenerationStatus<TData = Awaited<ReturnType<typeof getGenerationStatus>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGenerationStatus>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetGenerationStatus<TData = Awaited<ReturnType<typeof getGenerationStatus>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGenerationStatus>>, TError, TData>>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetGenerationStatusQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





# E2E SSE Test Implementation Plan

**Task:** E2E SSE Test  
**Description:** Say hello world and nothing else  
**Created:** 2025-01-01T18:55:51Z  
**Complexity:** S (Small)

## Technical Analysis

### Overview
Create a simple end-to-end test for the Server-Sent Events (SSE) infrastructure that verifies a "hello world" message can be sent and received through the SSE pipeline. This test will validate the complete SSE flow from backend emission to frontend reception.

### Current SSE Infrastructure (Based on Existing Codebase)
- **Backend SSE Infrastructure:** ✅ Complete with SSE endpoints and EventBuffer
- **Frontend SSE Hooks:** ✅ Complete with `useEventStream` and `useSessionActivitySSE`
- **Event System:** Events crate with tokio::broadcast bus
- **Existing Endpoints:** `/api/events` (global), `/api/sessions/{id}/activity` (per-session)

### Test Scope
- **Type:** Integration test (E2E)
- **Objective:** Verify SSE message delivery with minimal "hello world" payload
- **Coverage:** Backend emission → Network transport → Frontend reception

## Files to Modify/Create

### 1. Test Endpoint (Backend)
**Create:** `crates/server/src/routes/test_sse.rs`
- Simple test-only SSE endpoint that emits "hello world"
- Should be conditionally compiled for test builds only

### 2. Route Registration
**Modify:** `crates/server/src/routes/mod.rs`
- Add test_sse module import (conditional)
- Register test route in router

### 3. E2E Test File
**Create:** `crates/server/tests/e2e_sse_test.rs`
- Integration test that starts server and connects to SSE endpoint
- Validates "hello world" message reception

### 4. Test Configuration
**Modify:** `crates/server/Cargo.toml`
- Add any additional test dependencies if needed

## Step-by-Step Implementation

### Phase 1: Create Test SSE Endpoint
1. **Create test endpoint** (`crates/server/src/routes/test_sse.rs`)
   ```rust
   #[cfg(test)]
   use axum::response::sse::{Event, Sse};
   
   // Simple endpoint that sends "hello world" via SSE
   pub async fn hello_world_sse() -> Sse<impl Stream<Item = Result<Event, Infallible>>> {
       // Implementation details...
   }
   ```

2. **Register route conditionally** in `crates/server/src/routes/mod.rs`
   ```rust
   #[cfg(test)]
   pub mod test_sse;
   ```

3. **Add route to router** (test builds only)

### Phase 2: Create E2E Test
1. **Create integration test** (`crates/server/tests/e2e_sse_test.rs`)
   - Use `tokio_test` or similar for async testing
   - Start test server instance
   - Create SSE client connection
   - Listen for "hello world" message
   - Assert message content and timing

2. **Test structure:**
   ```rust
   #[tokio::test]
   async fn test_hello_world_sse() {
       // 1. Start test server
       // 2. Connect SSE client to /test/hello-world-sse
       // 3. Wait for "hello world" message
       // 4. Assert message received correctly
       // 5. Cleanup
   }
   ```

### Phase 3: Validation & Cleanup
1. **Run test:** `cargo test test_hello_world_sse`
2. **Verify:** Test passes and SSE message flows correctly
3. **Documentation:** Add test description to codebase docs
4. **Cleanup:** Ensure test endpoint is only available in test builds

## Potential Risks

### Low Risk
- **Test Isolation:** Test endpoint might interfere with production routes
  - *Mitigation:* Use `#[cfg(test)]` conditional compilation
- **Port Conflicts:** Test server might conflict with running dev server
  - *Mitigation:* Use dynamic port allocation in tests

### Medium Risk
- **SSE Connection Timing:** Race conditions between server start and client connect
  - *Mitigation:* Add proper wait mechanisms and timeouts
- **Test Flakiness:** Network-dependent test might be unstable
  - *Mitigation:* Use localhost only, reasonable timeouts

### Very Low Risk
- **Message Format:** SSE event format might not match expectations
  - *Mitigation:* Use existing SSE infrastructure patterns

## Success Criteria

1. ✅ Test endpoint successfully emits "hello world" via SSE
2. ✅ E2E test successfully receives the message
3. ✅ Test runs reliably in CI environment
4. ✅ No impact on production code (test-only compilation)
5. ✅ Test completes within reasonable time (< 5 seconds)

## Complexity Assessment: S (Small)

**Justification:**
- **SSE Infrastructure:** Already exists and working
- **Test Pattern:** Follows existing integration test patterns
- **Scope:** Minimal ("hello world" only)
- **Dependencies:** Uses existing libraries
- **Time Estimate:** 1-2 hours

**Complexity Breakdown:**
- Backend endpoint: 30 minutes
- E2E test setup: 45 minutes  
- Testing & refinement: 30 minutes
- Documentation: 15 minutes

## Dependencies

**Required:**
- Existing SSE infrastructure (✅ Available)
- Axum testing utilities (✅ Available)
- Tokio test runtime (✅ Available)

**Optional:**
- Additional SSE client libraries (if eventsource crate insufficient)

## Notes

- This test serves as a foundation for more complex SSE testing
- Can be extended later for multi-message scenarios
- Validates the complete SSE pipeline with minimal overhead
- Aligns with existing test patterns in the codebase
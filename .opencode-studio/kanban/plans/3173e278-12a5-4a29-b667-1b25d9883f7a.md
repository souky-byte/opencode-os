# Implementation Plan: Capture Idle

**Task ID:** 3173e278-12a5-4a29-b667-1b25d9883f7a  
**Title:** Capture idle  
**Description:** x  
**Created:** 2025-01-01T01:36:13Z

## Technical Analysis

### Problem Interpretation
Given the minimal description "x", this task is interpreted as implementing idle state detection and management within OpenCode Studio. This involves:

1. **Session Idle Detection**: Identifying OpenCode sessions that have been inactive
2. **Task Idle Detection**: Detecting tasks stuck in intermediate states
3. **Resource Cleanup**: Automatically handling idle resources to prevent resource leaks
4. **Monitoring & Metrics**: Tracking idle states for system health

### System Context
OpenCode Studio orchestrates AI-powered development tasks through:
- Task lifecycle: `TODO → PLANNING → PLANNING_REVIEW → IN_PROGRESS → AI_REVIEW → REVIEW → DONE`
- OpenCode session management for each phase
- SSE events for real-time updates
- VCS workspace management

### Idle State Scenarios
1. **Hanging Sessions**: OpenCode sessions that start but never complete
2. **Orphaned Tasks**: Tasks in intermediate states without active sessions
3. **Stale Workspaces**: VCS workspaces from abandoned tasks
4. **Resource Leaks**: Accumulated idle processes/connections

## Files to Modify/Create

### Core Domain
- `crates/core/src/domain/mod.rs` - Add idle detection traits
- `crates/core/src/domain/idle.rs` - New idle state domain models

### Database Layer
- `crates/db/migrations/002_idle_tracking.sql` - New migration for idle tracking
- `crates/db/src/models/mod.rs` - Export idle models
- `crates/db/src/models/idle_tracker.rs` - New idle state persistence
- `crates/db/src/repositories/mod.rs` - Export idle repository
- `crates/db/src/repositories/idle_repository.rs` - New idle state queries

### Orchestrator
- `crates/orchestrator/src/idle_monitor.rs` - New idle detection service
- `crates/orchestrator/src/cleanup.rs` - New cleanup service
- `crates/orchestrator/src/lib.rs` - Export new modules

### Server API
- `crates/server/src/routes/mod.rs` - Add idle routes
- `crates/server/src/routes/idle.rs` - New idle management endpoints
- `crates/server/src/state.rs` - Add idle monitor to app state

### Events
- `crates/events/src/types.rs` - Add idle-related events

### Frontend (Optional)
- `frontend/src/components/monitoring/IdleMonitor.tsx` - New monitoring component
- `frontend/src/api/generated/idle/` - Generated API hooks

## Step-by-Step Implementation

### Phase 1: Core Domain & Database (2-3 hours)

1. **Define Idle Domain Models**
   ```rust
   // crates/core/src/domain/idle.rs
   pub struct IdleSession {
       pub session_id: String,
       pub task_id: String,
       pub last_activity: DateTime<Utc>,
       pub idle_duration: Duration,
       pub idle_type: IdleType,
   }
   
   pub enum IdleType {
       NoActivity,
       UnresponsiveSession,
       StuckInPhase,
       OrphanedWorkspace,
   }
   ```

2. **Create Database Migration**
   ```sql
   -- migrations/002_idle_tracking.sql
   CREATE TABLE idle_sessions (
       id INTEGER PRIMARY KEY AUTOINCREMENT,
       session_id TEXT NOT NULL,
       task_id TEXT NOT NULL,
       detected_at DATETIME NOT NULL,
       last_activity DATETIME NOT NULL,
       idle_type TEXT NOT NULL,
       resolved BOOLEAN DEFAULT FALSE,
       FOREIGN KEY (task_id) REFERENCES tasks(id)
   );
   ```

3. **Implement Repository Layer**
   - Database models and CRUD operations
   - Queries for detecting idle patterns

### Phase 2: Idle Detection Service (3-4 hours)

4. **Create Idle Monitor Service**
   ```rust
   // crates/orchestrator/src/idle_monitor.rs
   pub struct IdleMonitor {
       db: Arc<Database>,
       event_bus: Arc<EventBus>,
       config: IdleConfig,
   }
   
   impl IdleMonitor {
       pub async fn scan_for_idle_sessions(&self) -> Result<Vec<IdleSession>>;
       pub async fn detect_hung_tasks(&self) -> Result<Vec<Task>>;
       pub async fn cleanup_idle_resources(&self) -> Result<CleanupReport>;
   }
   ```

5. **Implement Detection Logic**
   - Check for sessions inactive > threshold (e.g., 30 minutes)
   - Detect tasks stuck in intermediate states > threshold (e.g., 2 hours)
   - Identify orphaned VCS workspaces

6. **Add Background Monitoring**
   - Periodic scanning (every 5 minutes)
   - Event-driven detection on session state changes

### Phase 3: Cleanup & Recovery (2-3 hours)

7. **Implement Cleanup Service**
   ```rust
   // crates/orchestrator/src/cleanup.rs
   pub struct CleanupService {
       workspace_manager: Arc<WorkspaceManager>,
       opencode_client: Arc<OpenCodeClient>,
   }
   
   impl CleanupService {
       pub async fn cleanup_idle_session(&self, session_id: &str) -> Result<()>;
       pub async fn recover_stuck_task(&self, task_id: &str) -> Result<()>;
       pub async fn cleanup_orphaned_workspace(&self, workspace_id: &str) -> Result<()>;
   }
   ```

8. **Add Recovery Strategies**
   - Graceful session termination
   - Task state reset with notification
   - Workspace cleanup with backup

### Phase 4: API & Events (1-2 hours)

9. **Create REST Endpoints**
   ```rust
   // GET /api/idle/sessions - List idle sessions
   // POST /api/idle/cleanup - Trigger manual cleanup
   // GET /api/idle/stats - Idle statistics
   ```

10. **Add SSE Events**
    ```rust
    pub enum IdleEvent {
        IdleSessionDetected { session_id: String, idle_type: IdleType },
        CleanupCompleted { cleanup_report: CleanupReport },
        RecoveryAttempted { task_id: String, success: bool },
    }
    ```

### Phase 5: Integration & Testing (2-3 hours)

11. **Integrate with Orchestrator**
    - Start idle monitor as background service
    - Wire into existing executor lifecycle

12. **Add Configuration**
    ```rust
    pub struct IdleConfig {
        pub session_timeout: Duration,
        pub task_timeout: Duration,
        pub scan_interval: Duration,
        pub auto_cleanup: bool,
    }
    ```

13. **Write Comprehensive Tests**
    - Unit tests for detection logic
    - Integration tests for cleanup scenarios
    - Mock OpenCode client responses

### Phase 6: Frontend Integration (Optional - 1-2 hours)

14. **Create Monitoring UI**
    - Real-time idle session display
    - Manual cleanup triggers
    - System health dashboard

## Potential Risks

### High Risk
- **Resource Cleanup**: Aggressive cleanup could terminate valid long-running tasks
- **Race Conditions**: Cleanup while session is becoming active
- **Data Loss**: Improper workspace cleanup could lose uncommitted changes

### Medium Risk
- **False Positives**: Detecting idle when OpenCode is processing
- **Performance**: Frequent scanning could impact database performance
- **Notification Fatigue**: Too many idle alerts

### Low Risk
- **Configuration Complexity**: Tuning thresholds for different workload patterns
- **Monitoring Overhead**: Additional database storage for tracking

### Mitigation Strategies
1. **Grace Periods**: Multiple confirmation checks before cleanup
2. **Backup Before Cleanup**: Preserve state before resource cleanup
3. **Manual Override**: Allow users to prevent cleanup of specific sessions
4. **Incremental Rollout**: Start with detection-only, add cleanup gradually
5. **Comprehensive Logging**: Full audit trail of all idle detection and cleanup actions

## Estimated Complexity: **L (Large)**

### Breakdown
- **Medium complexity** for core detection logic
- **High complexity** for safe cleanup mechanisms
- **Medium complexity** for integration with existing systems
- **Low complexity** for API and frontend components

### Reasoning
- Requires careful state management across multiple systems
- Safety-critical cleanup logic needs extensive testing
- Integration with VCS, OpenCode, and database systems
- Moderate amount of new code (~800-1200 lines)
- Significant testing requirements for edge cases

### Time Estimate
- **Development**: 10-15 hours
- **Testing**: 5-8 hours
- **Integration & Documentation**: 2-3 hours
- **Total**: 17-26 hours

## Success Criteria

1. **Detection Accuracy**: >95% correct identification of truly idle sessions
2. **Recovery Rate**: >90% successful recovery of stuck tasks
3. **Resource Efficiency**: <1% CPU overhead for monitoring
4. **Zero Data Loss**: No committed work lost during cleanup
5. **Event Reliability**: All idle events properly propagated via SSE

## Future Enhancements

1. **Machine Learning**: Adaptive thresholds based on historical patterns
2. **Predictive Cleanup**: Detect likely-to-become-idle sessions
3. **Resource Optimization**: Hibernate instead of terminate
4. **Advanced Recovery**: Smart retry with modified parameters
5. **Metrics Dashboard**: Comprehensive idle state analytics
# Implementation Plan: Capture Test

**Task ID**: 15e199e2-08ad-4e67-af50-131803ca5edb  
**Title**: Capture test  
**Description**: Capture raw events  
**Created**: 2026-01-01T00:36:13Z

## Technical Analysis

### Current State Assessment

OpenCode Studio implements a sophisticated event-driven architecture with the following components:

**Existing Event Infrastructure:**
- **Event Bus**: `crates/events/src/bus.rs` - tokio::broadcast-based pub/sub system
- **Event Types**: `crates/events/src/types.rs` - 13 event types covering tasks, sessions, workspaces, projects
- **SSE Events**: Server-Sent Events for real-time frontend updates via `/api/events`
- **OpenCode Events**: `crates/orchestrator/src/opencode_events.rs` - Real-time OpenCode session monitoring
- **Event Count**: 8 existing tests in events crate, 108+ tests across workspace

**Event Flow Architecture:**
```
EventBus (tokio::broadcast) → SSE Stream → Frontend
     ↑                           ↑
Orchestrator                 Server Routes
     ↑                           ↑  
Task Lifecycle             HTTP API Endpoints
```

**Current Event Types:**
- Task events: created, updated, status_changed
- Session events: started, ended, agent.message, tool.execution  
- Workspace events: created, merged, deleted
- Project events: opened, closed
- System events: errors

**Gaps Identified:**
1. **No Event Capture Mechanism**: Events flow through broadcast channels but aren't persisted
2. **Testing Limitations**: No way to capture events during test runs for verification
3. **No Debugging Support**: Can't replay or analyze event sequences
4. **Missing Event History**: Events are ephemeral - no historical data
5. **No Event Filtering**: Cannot selectively capture specific event types

### Technical Requirements

The "Capture test" task appears to require implementing raw event capture functionality for:
- **Test Verification**: Capturing events during test runs to validate behavior
- **Debugging Support**: Recording event sequences for post-mortem analysis  
- **Development Tools**: Event replay and inspection capabilities
- **Quality Assurance**: Ensuring all expected events are emitted

### Architecture Decision

Implement an **EventCapture** system that can:
1. Subscribe to the EventBus and record all events
2. Filter events by type, task_id, or time range
3. Persist captured events for later analysis
4. Provide replay capabilities for testing
5. Integrate with existing test infrastructure

## Files to Modify/Create

### New Core Files

1. **`crates/events/src/capture.rs`** (NEW)
   - `EventCapture` struct with configurable filtering
   - `CaptureConfig` for filtering options
   - `CapturedEvent` struct with metadata
   - In-memory and persistent storage options

2. **`crates/events/src/storage.rs`** (NEW)
   - `EventStorage` trait for pluggable backends
   - `MemoryEventStorage` for tests
   - `FileEventStorage` for development/debugging
   - `DatabaseEventStorage` for production (optional)

### Database Extensions

3. **`crates/db/migrations/002_event_capture.sql`** (NEW)
   - `captured_events` table schema
   - Indexes for efficient querying by type, timestamp, task_id

4. **`crates/db/src/models/captured_event.rs`** (NEW)
   - `CapturedEvent` model for database persistence
   - Serialization/deserialization logic

5. **`crates/db/src/repositories/event_repository.rs`** (NEW)
   - Database CRUD operations for captured events
   - Query methods with filtering support

### Test Infrastructure

6. **`crates/events/src/test_utils.rs`** (NEW)
   - `EventCaptureTester` utility for test scenarios
   - Helper macros for event assertions
   - Test fixtures and mock data

7. **`crates/orchestrator/src/executor_test_capture.rs`** (NEW)
   - Integration tests using event capture
   - Validate task lifecycle events are emitted correctly
   - Test OpenCode session event capture

### API Extensions

8. **`crates/server/src/routes/events_capture.rs`** (NEW)
   - `/api/events/capture/start` - Start capturing
   - `/api/events/capture/stop` - Stop and return captured events  
   - `/api/events/capture/history` - Query historical events
   - `/api/events/capture/replay` - Replay event sequence (dev only)

### Modified Files

9. **`crates/events/src/lib.rs`**
   - Export new capture and storage modules
   - Add feature flags for capture functionality

10. **`crates/events/src/bus.rs`**
    - Add optional capture integration
    - Capture subscription management

11. **`crates/server/src/lib.rs`**
    - Include new events capture routes in OpenAPI schema

12. **`crates/db/src/lib.rs`**
    - Export new captured_event model and repository

13. **`crates/orchestrator/src/executor.rs`**
    - Optional event capture integration for development
    - Capture configuration via environment variables

## Step-by-Step Implementation Steps

### Phase 1: Core Capture Infrastructure (Day 1-2)

1. **Create Core Capture Module**
   ```rust
   // crates/events/src/capture.rs
   pub struct EventCapture {
       config: CaptureConfig,
       storage: Box<dyn EventStorage>,
       subscription: Option<broadcast::Receiver<EventEnvelope>>,
   }
   ```

2. **Implement Storage Abstraction**
   ```rust
   // crates/events/src/storage.rs
   #[async_trait]
   pub trait EventStorage: Send + Sync {
       async fn store(&mut self, event: CapturedEvent) -> Result<(), EventCaptureError>;
       async fn query(&self, filter: EventFilter) -> Result<Vec<CapturedEvent>, EventCaptureError>;
       async fn clear(&mut self) -> Result<(), EventCaptureError>;
   }
   ```

3. **Add Memory Storage Implementation**
   - `MemoryEventStorage` using `Vec<CapturedEvent>`
   - Thread-safe access with `Arc<RwLock<Vec<CapturedEvent>>>`
   - Filtering and querying logic

4. **Create CapturedEvent Model**
   ```rust
   pub struct CapturedEvent {
       pub id: Uuid,
       pub captured_at: DateTime<Utc>,
       pub event_envelope: EventEnvelope,
       pub context: Option<String>, // Additional debug info
   }
   ```

### Phase 2: Database Integration (Day 2-3)

5. **Database Schema Migration**
   ```sql
   CREATE TABLE captured_events (
       id TEXT PRIMARY KEY,
       captured_at DATETIME NOT NULL,
       event_id TEXT NOT NULL,
       event_type TEXT NOT NULL,
       event_timestamp DATETIME NOT NULL,
       event_data TEXT NOT NULL, -- JSON serialized EventEnvelope
       task_id TEXT,
       session_id TEXT,
       context TEXT
   );
   ```

6. **Database Models and Repository**
   - Implement `CapturedEvent` sqlx model
   - Create `EventRepository` with async methods
   - Add filtering and pagination support

7. **File Storage Implementation**
   - `FileEventStorage` using JSONL format
   - Rotation and cleanup policies
   - Compression support for large captures

### Phase 3: Test Infrastructure (Day 3-4)

8. **Create Test Utilities**
   ```rust
   // crates/events/src/test_utils.rs
   pub struct EventCaptureTester {
       capture: EventCapture,
       bus: EventBus,
   }
   
   impl EventCaptureTester {
       pub async fn assert_event_emitted<F>(&self, predicate: F) 
       where F: Fn(&Event) -> bool;
       
       pub async fn assert_event_sequence(&self, expected: Vec<Event>);
   }
   ```

9. **Integration Test Suite**
   - Test task lifecycle events are captured correctly
   - Test OpenCode session events are captured
   - Test event filtering and querying
   - Test concurrent capture scenarios

10. **Test Helper Macros**
    ```rust
    assert_event_captured!(capture, Event::TaskCreated { task_id, .. });
    assert_events_in_sequence!(capture, [
        Event::TaskCreated { .. },
        Event::TaskStatusChanged { .. }
    ]);
    ```

### Phase 4: API Integration (Day 4-5)

11. **REST API Endpoints**
    ```rust
    POST /api/events/capture/start
    {
        "filter": {
            "event_types": ["task.created", "task.status_changed"],
            "task_id": "optional-uuid",
            "duration_seconds": 300
        }
    }
    ```

12. **Server Integration**
    - Add capture routes to server
    - Integrate with existing SSE infrastructure
    - Add authorization/permissions for capture endpoints

13. **OpenAPI Documentation**
    - Document all capture endpoints
    - Add response schemas for captured events
    - Include filtering parameter documentation

### Phase 5: Advanced Features (Day 5-6)

14. **Event Replay System**
    - `EventReplayer` for recreating event sequences
    - Timeline reconstruction capabilities
    - Development/debugging tools

15. **Configuration Management**
    ```rust
    pub struct CaptureConfig {
        pub enabled: bool,
        pub storage_type: StorageType,
        pub max_events: Option<usize>,
        pub retention_days: Option<u32>,
        pub filter: EventFilter,
    }
    ```

16. **Performance Optimizations**
    - Async batch writing for high-volume scenarios
    - Background cleanup tasks
    - Memory usage monitoring and limits

### Phase 6: Testing and Documentation (Day 6-7)

17. **Comprehensive Test Suite**
    - Unit tests for all capture components
    - Integration tests with real EventBus
    - Performance tests for high event volumes
    - Error condition and edge case tests

18. **Documentation and Examples**
    - Usage examples in code comments
    - Integration guide for test developers
    - Performance tuning recommendations

## Potential Risks

### Technical Risks
- **Performance Impact**: Event capture could slow down the EventBus
  - **Mitigation**: Make capture optional, use async processing, implement batching
  
- **Memory Usage**: Large event captures could consume excessive memory
  - **Mitigation**: Implement size limits, streaming to disk, background cleanup

- **Storage Scaling**: Database/file storage could grow large over time  
  - **Mitigation**: Retention policies, compression, archival strategies

### Integration Risks
- **Test Flakiness**: Async event capture might introduce timing issues in tests
  - **Mitigation**: Proper synchronization, deterministic test helpers

- **Breaking Changes**: Adding capture might affect existing event flow
  - **Mitigation**: Feature flags, backward compatibility, thorough testing

### Development Risks  
- **Complexity Creep**: Feature could become overcomplicated
  - **Mitigation**: Start with minimal viable implementation, iterate

- **Maintenance Burden**: Additional code to maintain and debug
  - **Mitigation**: Good test coverage, clear documentation, simple design

## Estimated Complexity: **L (Large)**

### Justification
- **Multiple Crates Modified**: events, db, server, orchestrator (4 crates)
- **Database Schema Changes**: New table, migration, repository layer
- **New API Surface**: REST endpoints with filtering and querying
- **Complex Testing**: Integration tests across multiple components
- **Storage Abstractions**: Multiple storage backends to implement
- **Performance Considerations**: Async processing, memory management

### Complexity Breakdown
- **Core Capture Logic**: M (Medium) - Event subscription and filtering
- **Storage Layer**: M (Medium) - Multiple storage implementations  
- **Database Integration**: M (Medium) - Schema, models, repositories
- **API Layer**: S (Small) - Standard REST endpoints
- **Test Infrastructure**: L (Large) - Complex integration testing
- **Documentation**: S (Small) - Standard documentation tasks

**Total Estimated Time**: 6-7 days for experienced Rust developer

### Dependencies
- Requires understanding of existing EventBus architecture
- Database migration expertise (SQLite/sqlx)
- Async Rust patterns for performance
- Test infrastructure knowledge for integration tests

This implementation will provide comprehensive event capture capabilities for testing, debugging, and development scenarios while maintaining performance and backward compatibility.
# Implementation Plan: Execute Test - Enhanced Testing & Issue Resolution

**Task ID:** 1e29f7ae-7ddb-45db-b3f7-474e24f8744f  
**Title:** Execute Test  
**Description:** Test task execution with OpenCode  
**Created:** 2025-12-31 19:55  
**Updated:** 2025-12-31 19:55 (Enhanced with recent findings)  
**Estimated Complexity:** L (Large - due to critical issue resolution)

## 1. Technical Analysis

### Critical Issues Identified (Recent Testing)
Based on comprehensive E2E testing conducted previously:

1. **üö® Execution Timeout Issue**
   - `POST /api/tasks/{id}/execute` times out after 30 seconds
   - Endpoint blocks during execution instead of returning immediately
   - **Root Cause**: Synchronous execution pattern in API handler

2. **üö® Status Synchronization Failure**
   - Task status remains 'todo' in Studio DB despite OpenCode completion
   - OpenCode successfully creates sessions and modifies files (confirmed: 300 additions, 59 deletions)
   - **Root Cause**: Status update mechanism not working after OpenCode completion

3. **üö® Empty Session Activity**
   - `/api/sessions/{id}/activity` endpoint returns empty data
   - SSE events may not be properly captured
   - **Root Cause**: Activity store not properly populated

4. **‚úÖ Confirmed Working**
   - OpenCode integration creates sessions successfully  
   - File modifications occur as expected
   - SSE events for `task.status_changed` and `session.started` work
   - AGENTS.md generation works correctly

### Architecture Assessment
Current execution flow:
```
API Request ‚Üí executor.execute_phase() ‚Üí [BLOCKS] ‚Üí OpenCode Session ‚Üí File Changes ‚Üí Status Update Fails
```

Required flow:
```
API Request ‚Üí Start Background Task ‚Üí Immediate Response
Background: executor.execute_phase() ‚Üí OpenCode Session ‚Üí File Changes ‚Üí Status Update ‚Üí SSE Events
```

## 2. Files to Modify/Create

### Critical Fixes Required
| File | Issue | Required Change |
|------|-------|-----------------|
| `crates/server/src/routes/tasks.rs` | 30s timeout | Convert to async background execution |
| `crates/orchestrator/src/executor.rs` | Status sync failure | Add proper status update callbacks |
| `crates/db/src/repositories/session_repository.rs` | Empty activity | Implement activity tracking |
| `crates/orchestrator/src/activity_store.rs` | SSE data missing | Fix activity capture and storage |

### New Test Files
| File | Purpose |
|------|---------|
| `tests/e2e/critical_execution_flow.rs` | E2E test reproducing timeout/status issues |
| `crates/orchestrator/tests/executor_async_test.rs` | Async execution pattern testing |
| `crates/server/tests/execution_timeout_test.rs` | API timeout behavior testing |

### Supporting Infrastructure
| File | Purpose |
|------|---------|
| `crates/server/src/background_tasks.rs` | Background task management (NEW) |
| `crates/events/src/task_events.rs` | Enhanced task event definitions |

## 3. Step-by-Step Implementation

### Phase 1: Fix Critical Timeout Issue (High Priority - 2-3 hours)

1. **Create Background Task Infrastructure**
   ```rust
   // crates/server/src/background_tasks.rs
   pub struct BackgroundTaskManager {
       pub task_handles: Arc<Mutex<HashMap<TaskId, JoinHandle<Result<(), Error>>>>>,
   }
   
   impl BackgroundTaskManager {
       pub async fn execute_task_async(&self, task_id: TaskId) -> Result<(), Error>
       pub async fn get_execution_status(&self, task_id: TaskId) -> ExecutionStatus
   }
   ```

2. **Refactor Task Execution Endpoint**
   ```rust
   // crates/server/src/routes/tasks.rs - CRITICAL CHANGE
   pub async fn execute_task(
       Path(task_id): Path<TaskId>,
       State(app_state): State<AppState>,
   ) -> Result<Json<ExecuteResponse>, AppError> {
       // OLD: let result = executor.execute_phase(&task).await; // BLOCKS!
       
       // NEW: Start background execution
       let task_manager = &app_state.background_tasks;
       task_manager.execute_task_async(task_id).await?;
       
       // Return immediately with execution started status
       Ok(Json(ExecuteResponse {
           task_id,
           status: "execution_started".to_string(),
           message: "Task execution started in background".to_string(),
       }))
   }
   ```

3. **Test Timeout Fix**
   ```rust
   #[tokio::test]
   async fn test_execute_returns_immediately() {
       let response = client.post(format!("/api/tasks/{}/execute", task_id)).send().await;
       
       // Should return within 100ms, not 30+ seconds
       assert!(response.status().is_success());
       assert_eq!(response.json::<ExecuteResponse>().await.status, "execution_started");
   }
   ```

### Phase 2: Fix Status Synchronization (High Priority - 2-3 hours)

4. **Add Status Update Callbacks to Executor**
   ```rust
   // crates/orchestrator/src/executor.rs - CRITICAL FIX
   impl TaskExecutor {
       pub async fn execute_phase_with_callbacks(
           &self,
           task: &Task,
           status_callback: Box<dyn Fn(TaskStatus) + Send + Sync>,
       ) -> Result<PhaseResult, Error> {
           // Existing execution logic...
           
           // CRITICAL: Add status updates at each phase transition
           match task.status {
               TaskStatus::Todo => {
                   status_callback(TaskStatus::Planning);
                   // Execute planning...
                   status_callback(TaskStatus::PlanningReview);
               }
               TaskStatus::InProgress => {
                   // Execute implementation...
                   status_callback(TaskStatus::AiReview);
               }
               // etc.
           }
       }
   }
   ```

5. **Integrate Status Updates in Background Task**
   ```rust
   // Background task implementation
   let status_callback = {
       let task_repo = app_state.task_repository.clone();
       let event_bus = app_state.event_bus.clone();
       
       Box::new(move |new_status: TaskStatus| {
           // Update database
           task_repo.update_task_status(task_id, new_status).await?;
           
           // Emit SSE event
           event_bus.emit(TaskEvent::StatusChanged { task_id, new_status }).await?;
       })
   };
   
   executor.execute_phase_with_callbacks(&task, status_callback).await?;
   ```

6. **Test Status Updates Work**
   ```rust
   #[tokio::test]
   async fn test_status_updates_during_execution() {
       // Start task execution
       // Poll task status endpoint
       // Verify status progression: Todo ‚Üí Planning ‚Üí PlanningReview ‚Üí etc.
       // Verify final status is not stuck at 'todo'
   }
   ```

### Phase 3: Fix Session Activity Tracking (Medium Priority - 2 hours)

7. **Debug Activity Store Population**
   ```rust
   // crates/orchestrator/src/activity_store.rs - DEBUG
   impl SessionActivityRegistry {
       pub fn record_activity(&mut self, session_id: &str, activity: ActivityMessage) {
           tracing::info!("Recording activity for session {}: {:?}", session_id, activity);
           // Existing logic + debug logging
       }
   }
   ```

8. **Fix Session Activity Endpoint**
   ```rust
   // Investigate why /api/sessions/{id}/activity returns empty
   // Add proper activity capture during OpenCode session execution
   // Ensure activity store is properly connected to executor
   ```

### Phase 4: Comprehensive E2E Testing (Medium Priority - 2-3 hours)

9. **Create Full Execution Test**
   ```rust
   #[tokio::test]
   async fn test_full_task_execution_e2e() {
       // 1. Create task via API
       // 2. Start execution (should return immediately)
       // 3. Poll status until completion
       // 4. Verify OpenCode session was created
       // 5. Verify file changes occurred
       // 6. Verify final status is 'done' or appropriate end state
       // 7. Verify session activity was captured
   }
   ```

10. **Test Concurrent Executions**
    ```rust
    #[tokio::test]
    async fn test_multiple_concurrent_executions() {
        // Start 5 tasks simultaneously
        // Verify all execute without interfering
        // Verify proper resource isolation
    }
    ```

### Phase 5: Performance & Monitoring (Low Priority - 1-2 hours)

11. **Add Execution Monitoring**
    - Metrics for execution duration
    - Status update success/failure tracking
    - OpenCode integration health monitoring

12. **Load Testing**
    - Test 10+ concurrent task executions
    - Monitor memory usage and performance
    - Verify database connection pooling works

## 4. Potential Risks

### Critical Risks (High Impact)
| Risk | Impact | Mitigation |
|------|--------|------------|
| **Background task crashes** | Task stuck in limbo | Add task timeout and recovery mechanisms |
| **Database transaction deadlock** | Status updates fail | Use proper transaction isolation and retry logic |
| **Memory leaks from long tasks** | Server instability | Implement task cleanup and resource limits |
| **OpenCode session orphaning** | Resources not cleaned up | Add session cleanup on task completion/failure |

### Medium Risks
| Risk | Impact | Mitigation |
|------|--------|------------|
| **SSE connection failures** | UI not updated | Add connection retry and fallback polling |
| **VCS operation conflicts** | File corruption | Use proper locking and atomic operations |
| **Activity store corruption** | Lost execution logs | Add data validation and backup mechanisms |

## 5. Estimated Complexity: L (Large)

### Reasoning
- **Multiple critical issues** requiring architectural changes
- **Background execution** is a significant paradigm shift  
- **Status synchronization** touches multiple systems (DB, events, OpenCode)
- **Testing complexity** requires E2E scenarios and race condition testing
- **Risk assessment** shows multiple high-impact failure modes

### Time Breakdown
| Phase | Effort | Priority |
|-------|--------|----------|
| Fix timeout (async execution) | 2-3 hours | üö® Critical |
| Fix status synchronization | 2-3 hours | üö® Critical |
| Fix session activity | 2 hours | ‚ö†Ô∏è High |
| E2E testing | 2-3 hours | ‚ö†Ô∏è High |
| Performance & monitoring | 1-2 hours | ‚ÑπÔ∏è Medium |
| **Total** | **9-13 hours** | |

## 6. Success Criteria

### Critical (Must Fix)
- [ ] `POST /api/tasks/{id}/execute` returns within 500ms
- [ ] Task status correctly progresses through lifecycle
- [ ] Task status updates are persisted to database
- [ ] Final task status reflects actual OpenCode completion
- [ ] No 30-second timeouts during normal operation

### High Priority
- [ ] `/api/sessions/{id}/activity` returns populated data
- [ ] SSE events are emitted for all status changes
- [ ] Multiple concurrent executions work without interference
- [ ] OpenCode sessions are properly created and tracked

### Medium Priority  
- [ ] Comprehensive test coverage for new execution flow
- [ ] Performance metrics and monitoring in place
- [ ] Documentation updated with new architecture
- [ ] Error handling for all edge cases

## 7. Testing Strategy

### Critical Path Testing
```rust
// Test the exact scenario that failed before
#[tokio::test] 
async fn test_reproduce_timeout_issue() {
    // This test MUST pass to confirm fix
    let start = Instant::now();
    let response = execute_task_api(task_id).await;
    let duration = start.elapsed();
    
    assert!(duration < Duration::from_millis(500)); // No more 30s timeouts!
    assert_eq!(response.status, "execution_started");
}

#[tokio::test]
async fn test_reproduce_status_sync_issue() {
    // This test MUST pass to confirm fix
    execute_task_api(task_id).await;
    
    // Poll until completion (with reasonable timeout)
    let final_status = poll_task_status_until_complete(task_id).await;
    assert_ne!(final_status, TaskStatus::Todo); // Must not remain 'todo'!
}
```

### Regression Testing
- All existing tests must continue to pass
- Performance must not degrade for other operations
- UI must continue to work with new async execution model

## 8. Rollback Plan

### Immediate Rollback (if critical failures)
1. **Feature flag**: Disable new async execution, revert to synchronous
2. **Database rollback**: Restore task status update mechanism
3. **Monitor**: Watch for any database corruption or task stuck states

### Partial Rollback (if some features fail)
- Keep async execution but disable concurrent execution limits
- Fall back to polling for status updates if SSE fails
- Disable session activity tracking if it causes performance issues

## 9. Implementation Notes

### Known Technical Debt to Address
- `crates/cli` still uses path dependencies instead of workspace dependencies
- Some clippy warnings may need resolution after changes
- OpenCode SDK integration may need error handling improvements

### Integration Points to Verify
- **Frontend**: Ensure UI handles new async execution responses properly
- **SSE**: Verify frontend receives status update events
- **Database**: Confirm transaction isolation works with background tasks  
- **VCS**: Ensure workspace operations don't conflict with concurrent executions

---

**Next Steps:**
1. **IMMEDIATE**: Start with Phase 1 (timeout fix) - highest priority
2. **URGENT**: Implement Phase 2 (status sync) - critical for user experience  
3. **HIGH**: Complete Phase 3 (activity tracking) - important for debugging
4. **VALIDATE**: Run comprehensive E2E tests to confirm all fixes work

**Dependencies:**
- OpenCode server must be available for testing
- SQLite database for integration testing
- VCS operations (jj/git) for workspace testing

**Success Metrics:**
- Zero execution timeouts during normal operation
- 100% status update success rate
- Sub-second API response times for execution requests
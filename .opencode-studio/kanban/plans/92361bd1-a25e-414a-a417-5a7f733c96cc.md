# Implementation Plan: Add Greeting Function

## Task Overview
**Title:** Add greeting function  
**Description:** Create a simple greeting.rs file in crates/core/src/ with a pub fn greet(name: &str) -> String function that returns Hello, {name}!  
**Task ID:** 92361bd1-a25e-414a-a417-5a7f733c96cc  
**Generated:** 2025-12-31T19:55:51Z  
**Updated:** 2025-12-31T20:55:51Z  
**Complexity:** S (Small)  
**Estimated Time:** 5-10 minutes  

## 1. Technical Analysis

### Current State
- The `opencode_core` crate follows a clean domain-driven architecture
- Current structure in `crates/core/src/`:
  - `lib.rs` - Main module file that re-exports domain modules
  - `domain/mod.rs` - Domain module aggregator (contains session.rs, task.rs)
  - `error.rs` - Error handling types
- The crate exports as `opencode_core` to avoid Rust reserved word conflicts
- No existing greeting functionality present

### Proposed Solution
Add a simple utility function at the root level of the crate. This placement is appropriate since greeting functionality is a utility function rather than core business logic, and should remain outside the domain layer.

### Architecture Considerations
- The greeting function must be pure (no I/O) to align with the core crate's constraints
- Should follow standard Rust conventions for public APIs
- Minimal implementation with clear, testable behavior
- Follows the "NO I/O" rule for the core crate as specified in AGENTS.md

### Dependencies & Integration
- No external dependencies required (uses only std library)
- No impact on existing workspace dependency graph
- Will be accessible as `opencode_core::greet` from other crates

## 2. Files to Create/Modify

### 2.1 Create `crates/core/src/greeting.rs`
**Type:** New File  
**Purpose:** Contains the greeting function implementation

**Content Structure:**
```rust
/// Generates a greeting message for the given name
/// 
/// # Arguments
/// * `name` - The name to include in the greeting
/// 
/// # Returns
/// A String containing "Hello, {name}!"
/// 
/// # Examples
/// ```
/// use opencode_core::greet;
/// 
/// let message = greet("World");
/// assert_eq!(message, "Hello, World!");
/// ```
pub fn greet(name: &str) -> String {
    format!("Hello, {}!", name)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_greet_simple() {
        let result = greet("World");
        assert_eq!(result, "Hello, World!");
    }

    #[test]
    fn test_greet_empty_string() {
        let result = greet("");
        assert_eq!(result, "Hello, !");
    }

    #[test]
    fn test_greet_with_spaces() {
        let result = greet("John Doe");
        assert_eq!(result, "Hello, John Doe!");
    }

    #[test]
    fn test_greet_unicode() {
        let result = greet("世界");
        assert_eq!(result, "Hello, 世界!");
    }
}
```

### 2.2 Modify `crates/core/src/lib.rs`
**Type:** File Modification  
**Purpose:** Add module declaration and public re-export

**Current Content (lines 1-6):**
```rust
pub mod domain;
pub mod error;

pub use domain::*;
pub use error::*;
```

**Required Changes:**
```rust
pub mod domain;
pub mod error;
pub mod greeting;  // ADD THIS LINE

pub use domain::*;
pub use error::*;
pub use greeting::*;  // ADD THIS LINE
```

## 3. Step-by-Step Implementation

### Step 1: Create the greeting module
1. Navigate to `crates/core/src/`
2. Create new file `greeting.rs`
3. Implement the function with:
   - Complete rustdoc documentation with examples
   - Main `greet` function implementation using `format!` macro
   - Comprehensive test suite covering edge cases:
     - Basic functionality test
     - Empty string handling
     - Multi-word names with spaces
     - Unicode character support

### Step 2: Update module system
1. Open `crates/core/src/lib.rs`
2. Add `pub mod greeting;` declaration after existing module declarations
3. Add `pub use greeting::*;` re-export after existing re-exports
4. Maintain consistent formatting with existing code

### Step 3: Verify implementation
1. **Compilation check:** `cargo check -p opencode_core`
2. **Test execution:** `cargo test -p opencode_core`
3. **Lint verification:** `cargo clippy -p opencode_core -- -D warnings`
4. **Format check:** `cargo fmt`
5. **Documentation test:** Verify rustdoc examples work correctly

### Step 4: Integration verification
1. Verify the function can be imported as `opencode_core::greet`
2. Check that existing exports still work correctly
3. Ensure no breaking changes to the public API
4. Confirm workspace-level tests still pass: `cargo test --workspace`

## 4. Potential Risks

### Low Risk Items

**4.1 Module System Integration**
- **Risk:** The module might not be properly exposed through lib.rs
- **Impact:** Function not accessible from other crates
- **Mitigation:** Follow exact pattern used by existing modules (domain, error)
- **Detection:** Test import with `use opencode_core::greet;`

**4.2 Function Signature Compliance**
- **Risk:** Function might not match exact specification
- **Impact:** Does not meet requirements
- **Mitigation:** Implement exactly as specified: `pub fn greet(name: &str) -> String`
- **Detection:** Unit tests verify exact output format

### Minimal Risk Items

**4.3 Breaking Changes**
- **Risk:** New public API might conflict with existing code
- **Impact:** Build failures in dependent crates
- **Assessment:** Extremely unlikely - this is purely additive
- **Mitigation:** New function addition only, no modifications to existing code

**4.4 Performance Impact**
- **Risk:** String allocation on each call
- **Impact:** Slight memory overhead
- **Assessment:** Acceptable for a utility function
- **Mitigation:** Using efficient `format!` macro, standard approach

**4.5 Memory Safety**
- **Risk:** String handling issues
- **Impact:** Runtime errors or memory leaks
- **Assessment:** Negligible - using standard library functions
- **Mitigation:** Rust's memory safety guarantees apply, no unsafe code

### Risk Mitigation Matrix

| Risk | Likelihood | Impact | Mitigation Strategy |
|------|------------|---------|-------------------|
| Module integration | Low | Medium | Follow existing patterns exactly |
| Function signature | Very Low | Medium | Implement per spec, test thoroughly |
| Breaking changes | Very Low | High | Additive changes only |
| Performance | Low | Low | Accept trade-off for simplicity |
| Memory safety | Very Low | High | Use standard library only |

## 5. Testing Strategy

### 5.1 Unit Tests (Included in implementation)
```rust
#[test]
fn test_greet_simple() {
    let result = greet("World");
    assert_eq!(result, "Hello, World!");
}

#[test]
fn test_greet_empty_string() {
    let result = greet("");
    assert_eq!(result, "Hello, !");
}

#[test]
fn test_greet_with_spaces() {
    let result = greet("John Doe");
    assert_eq!(result, "Hello, John Doe!");
}

#[test]
fn test_greet_unicode() {
    let result = greet("世界");
    assert_eq!(result, "Hello, 世界!");
}
```

### 5.2 Integration Tests
- **Module Export Test:** Verify `use opencode_core::greet` works from external code
- **Documentation Test:** Ensure rustdoc examples compile and run correctly
- **Workspace Test:** Confirm no regressions in other crates

### 5.3 Verification Commands
```bash
# 1. Compilation verification
cargo check -p opencode_core

# 2. Test execution
cargo test -p opencode_core

# 3. Lint checking (strict warnings)
cargo clippy -p opencode_core -- -D warnings

# 4. Format verification
cargo fmt --check

# 5. Workspace-wide test
cargo test --workspace

# 6. Documentation test
cargo test --doc -p opencode_core
```

### 5.4 Test Coverage Expectations
- **Function coverage:** 100% (all branches covered)
- **Edge case coverage:** 90%+ (empty strings, Unicode, spaces)
- **Documentation coverage:** 100% (all examples tested)

## 6. Estimated Complexity: S (Small)

### 6.1 Complexity Justification
- **Single function implementation** - minimal scope
- **No external dependencies** - uses only std library
- **No database changes** - pure function only
- **No API modifications** - internal utility function
- **Straightforward testing** - clear input/output relationship
- **Well-defined scope** - exact specification provided
- **Zero breaking changes** - additive only

### 6.2 Time Estimation Breakdown
| Activity | Estimated Time | Percentage |
|----------|---------------|------------|
| File creation & function implementation | 3-5 minutes | 40% |
| Test suite development | 2-3 minutes | 25% |
| Module integration (lib.rs) | 1-2 minutes | 15% |
| Documentation & rustdoc | 2-3 minutes | 20% |
| **Total Implementation Time** | **8-13 minutes** | **100%** |

### 6.3 Confidence Assessment
- **Confidence Level:** Very High (95%+)
- **Risk of overrun:** Very Low
- **Complexity creep potential:** None (scope well-defined)
- **Dependency on external factors:** None

## 7. Success Criteria

### 7.1 Functional Requirements
- [ ] Function `greet(name: &str) -> String` exists and is publicly accessible
- [ ] Function returns exactly `"Hello, {name}!"` format for any input
- [ ] Function handles edge cases gracefully (empty strings, Unicode, spaces)
- [ ] Function is accessible as `opencode_core::greet` from external crates
- [ ] All test cases pass successfully

### 7.2 Technical Requirements
- [ ] Code compiles without errors: `cargo check -p opencode_core`
- [ ] All tests pass: `cargo test -p opencode_core`
- [ ] Lint checks pass: `cargo clippy -p opencode_core -- -D warnings`
- [ ] Code formatting is correct: `cargo fmt --check`
- [ ] Documentation tests pass: `cargo test --doc -p opencode_core`
- [ ] Workspace tests still pass: `cargo test --workspace`

### 7.3 Code Quality Requirements
- [ ] Function includes comprehensive rustdoc documentation
- [ ] Documentation includes working examples
- [ ] Test coverage > 90% for new code
- [ ] Follows project Rust conventions and style guidelines
- [ ] No new clippy warnings introduced
- [ ] Maintains crate's "no I/O" constraint

### 7.4 Integration Requirements
- [ ] Module properly declared in `lib.rs`
- [ ] Function properly exported through `pub use`
- [ ] No conflicts with existing module names
- [ ] No breaking changes to existing API surface
- [ ] Function works from other crates in workspace

## 8. Implementation Notes

### 8.1 Design Decisions
- **Placement:** Root level of crate (not in domain/) since this is utility functionality
- **Error Handling:** Minimal - `format!` cannot fail with basic string inputs
- **Performance:** Accepting String allocation for simplicity and clarity
- **API Design:** Using `&str` parameter for efficiency (no unnecessary allocations)

### 8.2 Code Style Adherence
- Follow existing rustdoc comment patterns
- Use consistent indentation and formatting
- Include comprehensive examples in documentation
- Maintain inline test pattern: `#[cfg(test)] mod tests`

### 8.3 Future Extensibility
- Function is designed to be self-contained
- Could be extended later for internationalization
- Template-based greeting formats could be added
- No architectural constraints for future enhancements

This implementation plan ensures a clean, well-tested, and properly integrated greeting function that follows all project conventions and requirements.
# Implementation Plan: Test SSE v2

## Task Analysis
**Title:** Test SSE v2  
**Description:** Quick test  
**Plan ID:** 42944d6d-7561-4030-afed-f425f9e4f279  
**Created:** 2026-01-01T01:36:13+01:00

## 1. Technical Analysis

### Context
Based on project knowledge, OpenCode Studio has recently migrated from WebSocket to Server-Sent Events (SSE) for real-time communication. The SSE infrastructure is largely complete, but comprehensive testing is needed to ensure reliability and proper functionality.

### Current SSE Implementation Status
- ‚úÖ Backend SSE Infrastructure (Feature 1) - Complete
- ‚úÖ Frontend SSE Hooks (Feature 2) - Complete  
- ‚úÖ Backend Activity Message Serialization (Feature 3) - Complete
- üü° WebSocket Code Cleanup (Feature 4) - In Progress
- ‚ùå Documentation & Testing (Feature 5) - Pending

### Key SSE Components to Test
1. **Global Event Stream**: `/api/events` endpoint
2. **Session Activity Stream**: `/api/sessions/{id}/activity` endpoint  
3. **Frontend Hooks**: `useEventStream` and `useSessionActivitySSE`
4. **Event Types**: `task.status_changed`, `session.started`, `session.ended`
5. **Reconnection Logic**: Auto-reconnect and history replay
6. **EventBuffer**: Server-side buffering for reconnection scenarios

### Known Issues to Address
- `/api/sessions/{id}/activity` endpoint previously returned empty responses
- Task status synchronization issues between OpenCode and Studio DB
- 30-second timeout issues during task execution

## 2. Files to Modify/Create

### Test Files to Create
```
crates/server/src/routes/events_test.rs          # SSE endpoint integration tests
crates/server/src/routes/sessions_test.rs        # Session activity SSE tests
frontend/src/hooks/__tests__/useEventStream.test.ts     # Frontend hook unit tests
frontend/src/hooks/__tests__/useSessionActivitySSE.test.ts
tests/integration/sse_integration_test.rs        # End-to-end SSE tests
tests/manual/sse_manual_test.md                  # Manual testing checklist
```

### Files to Review/Modify
```
crates/server/src/routes/events.rs               # Verify SSE implementation
crates/server/src/routes/sessions.rs             # Check session activity endpoint
crates/orchestrator/src/executor.rs              # Event emission verification
frontend/src/hooks/useEventStream.ts             # Hook reliability
frontend/src/hooks/useSessionActivitySSE.ts      # Session-specific SSE
crates/events/src/bus.rs                         # Event bus functionality
```

## 3. Step-by-Step Implementation

### Phase 1: Backend SSE Testing (Day 1)
1. **Create SSE endpoint integration tests**
   - Test `/api/events` connection establishment
   - Verify proper SSE headers (`text/event-stream`, `Cache-Control: no-cache`)
   - Test event emission for task status changes
   - Test event emission for session lifecycle

2. **Create session activity SSE tests**
   - Test `/api/sessions/{id}/activity` endpoint
   - Verify session-specific event filtering
   - Test with valid and invalid session IDs
   - Verify event format and data integrity

3. **Test EventBuffer functionality**
   - Test event buffering for reconnection scenarios
   - Verify buffer size limits and cleanup
   - Test history replay on reconnection

### Phase 2: Event Emission Testing (Day 1-2)
4. **Verify orchestrator event emission**
   - Test task status change events from `executor.rs`
   - Test session started/ended events
   - Verify event payload structure matches frontend expectations

5. **Test event bus reliability**
   - Test event delivery across multiple subscribers
   - Test event ordering and timing
   - Test error handling in event processing

### Phase 3: Frontend Hook Testing (Day 2)
6. **Unit test useEventStream hook**
   - Test connection establishment
   - Test auto-reconnection logic
   - Test event parsing and state updates
   - Test cleanup on unmount

7. **Unit test useSessionActivitySSE hook**
   - Test session-specific event handling
   - Test hook behavior with invalid session IDs
   - Test event filtering and processing

### Phase 4: Integration Testing (Day 2-3)
8. **End-to-end SSE flow testing**
   - Create task ‚Üí verify SSE event received
   - Execute task ‚Üí verify status change events
   - Test concurrent connections from multiple clients
   - Test browser tab switching and reconnection

9. **Performance and reliability testing**
   - Test with high event frequency
   - Test connection stability over extended periods
   - Test memory usage and cleanup
   - Test graceful degradation scenarios

### Phase 5: Manual Testing & Documentation (Day 3)
10. **Manual testing checklist**
    - Browser DevTools Network tab verification
    - Real-time UI updates validation
    - Cross-browser compatibility check
    - Mobile/responsive behavior

11. **Update documentation**
    - Document SSE testing procedures
    - Update AGENTS.md with testing information
    - Create troubleshooting guide for SSE issues

## 4. Potential Risks

### High Risk
- **SSE Connection Instability**: Intermittent connection drops could affect real-time updates
- **Event Loss**: Network issues or server restarts could cause event loss
- **Browser Compatibility**: Older browsers may have SSE limitations

### Medium Risk  
- **Performance Impact**: High-frequency events could impact server performance
- **Memory Leaks**: Improper cleanup of SSE connections or event buffers
- **Race Conditions**: Event ordering issues between task operations and SSE updates

### Low Risk
- **Test Complexity**: Creating comprehensive SSE tests may require complex setup
- **Debugging Difficulty**: SSE issues can be harder to debug than traditional REST APIs
- **CORS Issues**: Cross-origin SSE requests may need special configuration

## 5. Testing Strategy

### Unit Tests
- Mock SSE connections for isolated testing
- Test event parsing and state management
- Test error handling and reconnection logic

### Integration Tests  
- Use real SSE connections within test environment
- Test full event flow from backend to frontend
- Test concurrent connections and scaling

### Manual Tests
- Browser DevTools for connection monitoring
- Network simulation for connection drops
- UI validation for real-time updates

### Performance Tests
- Load testing with multiple concurrent SSE connections
- Event frequency stress testing
- Memory usage monitoring over time

## 6. Success Criteria

### Functional Requirements
- [ ] SSE endpoints return proper headers and maintain connections
- [ ] Events are delivered correctly to all connected clients
- [ ] Frontend hooks handle events and update UI in real-time
- [ ] Reconnection logic works seamlessly on connection drops
- [ ] Session-specific events are properly filtered

### Non-Functional Requirements
- [ ] SSE connections remain stable for 30+ minutes
- [ ] Event delivery latency < 100ms under normal load
- [ ] Memory usage remains stable with long-lived connections
- [ ] System handles 50+ concurrent SSE connections
- [ ] Graceful degradation when SSE is unavailable

### Quality Requirements
- [ ] All unit tests pass (target: 95%+ coverage)
- [ ] All integration tests pass
- [ ] Manual testing checklist completed
- [ ] Documentation updated and reviewed
- [ ] Performance benchmarks meet targets

## 7. Estimated Complexity: **M (Medium)**

**Reasoning:**
- **Medium scope**: Testing existing SSE infrastructure rather than building new features
- **Well-defined requirements**: Clear understanding of what needs to be tested
- **Existing codebase**: SSE implementation already exists, reducing complexity
- **Standard testing patterns**: Can use established testing frameworks and patterns
- **Time estimate**: 2-3 days for comprehensive testing suite

**Complexity breakdown:**
- Backend testing: Simple-Medium (standard HTTP endpoint testing)
- Frontend testing: Medium (SSE mock setup required)  
- Integration testing: Medium (requires coordination between backend/frontend)
- Manual testing: Simple (straightforward browser testing)

## 8. Dependencies

- Existing SSE implementation in `crates/server/src/routes/events.rs`
- Frontend hooks in `frontend/src/hooks/useEventStream.ts`
- Event bus functionality in `crates/events/src/bus.rs`
- Test infrastructure and frameworks already in place

## 9. Next Steps

1. Begin with backend SSE endpoint testing
2. Validate event emission from orchestrator
3. Create frontend hook tests with proper mocking
4. Implement end-to-end integration tests
5. Conduct manual testing and documentation updates

---
**Plan Status:** Ready for Implementation  
**Assigned:** Pending  
**Priority:** Medium
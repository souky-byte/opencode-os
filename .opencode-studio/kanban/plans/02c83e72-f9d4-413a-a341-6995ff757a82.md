# Implementation Plan: Watch Idle

**Task ID:** 02c83e72-f9d4-413a-a341-6995ff757a82  
**Title:** Watch idle  
**Description:** x  
**Generated:** 2025-01-01T01:36:13+01:00

## 1. Technical Analysis

### Problem Statement
The task "Watch idle" with minimal description requires interpretation. Based on OpenCode Studio's architecture, this likely involves implementing idle detection and management for:
- Long-running OpenCode sessions that have become unresponsive
- Tasks stuck in intermediate states (Planning, InProgress, etc.)
- System resources monitoring for idle cleanup
- Session timeout management

### Current System Context
- **Task Lifecycle:** TODO → PLANNING → PLANNING_REVIEW → IN_PROGRESS → AI_REVIEW → REVIEW → DONE
- **Session Management:** Each phase runs as separate OpenCode session
- **Event System:** `tokio::broadcast` event bus for real-time updates
- **Persistence:** SQLite database with task/session tracking
- **Known Issue:** Tasks timing out after 30s in `POST /api/tasks/{id}/execute`

### Proposed Solution
Implement an **Idle Watch Service** that:
1. **Session Monitoring:** Detect OpenCode sessions running longer than threshold
2. **Task State Monitoring:** Identify tasks stuck in intermediate states
3. **Health Checks:** Periodic validation of OpenCode connectivity
4. **Cleanup Actions:** Automatic timeout handling and resource cleanup
5. **Notifications:** Event emission for idle state changes

## 2. Files to Modify/Create

### New Files
```
crates/orchestrator/src/idle_watch.rs       # Core idle monitoring logic
crates/orchestrator/src/idle_config.rs      # Configuration structures
crates/server/src/routes/idle.rs             # Idle management API endpoints
migrations/003_idle_tracking.sql             # Database schema updates
```

### Files to Modify
```
crates/orchestrator/src/lib.rs               # Export new modules
crates/orchestrator/src/executor.rs          # Integrate idle monitoring
crates/orchestrator/Cargo.toml               # Add tokio-cron-scheduler dependency
crates/server/src/lib.rs                     # Register idle routes
crates/server/src/routes/mod.rs              # Add idle module
crates/core/src/domain/session.rs           # Add idle-related fields
crates/core/src/domain/task.rs               # Add last_activity timestamp
crates/db/src/models/session.rs              # Database model updates
crates/db/src/repositories/session_repository.rs # Idle queries
crates/events/src/types.rs                   # New idle events
```

## 3. Step-by-Step Implementation

### Phase 1: Data Model Updates (30 min)
1. **Database Migration**
   - Add `last_activity` timestamp to tasks table
   - Add `idle_since` timestamp to sessions table
   - Add `idle_threshold_minutes` configuration table

2. **Domain Model Updates**
   - Extend `Task` struct with idle tracking fields
   - Extend `Session` struct with idle metadata
   - Add `IdleStatus` enum: `Active`, `Idle`, `TimedOut`

### Phase 2: Core Idle Detection (1 hour)
3. **Idle Watch Service (`idle_watch.rs`)**
   ```rust
   pub struct IdleWatchService {
       db: Arc<DatabasePool>,
       event_bus: EventBus,
       config: IdleConfig,
   }
   
   impl IdleWatchService {
       pub async fn start_monitoring(&self) -> Result<(), Error>
       pub async fn check_idle_sessions(&self) -> Result<Vec<Session>, Error>
       pub async fn check_idle_tasks(&self) -> Result<Vec<Task>, Error>
       pub async fn handle_idle_session(&self, session: &Session) -> Result<(), Error>
   }
   ```

4. **Configuration Management (`idle_config.rs`)**
   ```rust
   #[derive(Debug, Clone)]
   pub struct IdleConfig {
       pub session_idle_threshold: Duration,
       pub task_idle_threshold: Duration,
       pub check_interval: Duration,
       pub auto_timeout_enabled: bool,
   }
   ```

### Phase 3: Scheduler Integration (45 min)
5. **Background Task Scheduler**
   - Use `tokio-cron-scheduler` for periodic checks
   - Default: check every 30 seconds
   - Configurable via environment variables

6. **Event Integration**
   - Add `SessionIdle`, `SessionTimedOut`, `TaskIdle` events
   - Emit through existing EventBus
   - Update SSE streams to include idle events

### Phase 4: API Endpoints (30 min)
7. **REST API (`routes/idle.rs`)**
   ```
   GET  /api/idle/sessions     # List idle sessions
   GET  /api/idle/tasks        # List idle tasks  
   POST /api/idle/timeout/{id} # Force timeout specific session
   GET  /api/idle/config       # Get idle configuration
   PUT  /api/idle/config       # Update idle configuration
   ```

### Phase 5: Integration & Testing (45 min)
8. **Executor Integration**
   - Update `run_full_cycle()` to track activity timestamps
   - Add heartbeat mechanism for long-running operations
   - Handle idle detection during OpenCode execution

9. **Database Queries**
   - Add `find_idle_sessions(threshold: Duration)` 
   - Add `find_idle_tasks(threshold: Duration)`
   - Add `update_activity_timestamp(id: Uuid)`

10. **Unit Tests**
    - Idle detection logic tests
    - Configuration parsing tests
    - Database query tests
    - Event emission tests

## 4. Potential Risks

### High Risk
- **Unclear Requirements:** Minimal task description requires assumptions
- **False Positives:** Legitimate long-running tasks marked as idle
- **Resource Cleanup:** Risk of prematurely terminating valid sessions
- **Database Locks:** Concurrent access during idle checks vs. normal operations

### Medium Risk
- **Performance Impact:** Additional periodic database queries
- **Configuration Complexity:** Threshold tuning for different task types
- **Event Flooding:** Too frequent idle checks generating excessive events

### Low Risk
- **Dependency Addition:** `tokio-cron-scheduler` increases binary size
- **API Surface Expansion:** New endpoints require documentation

### Mitigation Strategies
1. **Gradual Rollout:** Start with monitoring-only mode, no automatic actions
2. **Configurable Thresholds:** Per-task-type idle timeouts
3. **Manual Override:** Always allow human intervention to prevent timeouts
4. **Comprehensive Logging:** Detailed audit trail for idle detection decisions
5. **Circuit Breaker:** Disable idle monitoring if system is under heavy load

## 5. Estimated Complexity

**Size:** **M (Medium)**

### Justification
- **Lines of Code:** ~400-500 lines across multiple files
- **New Concepts:** Idle detection patterns, background scheduling
- **Integration Points:** 4 crates (orchestrator, server, core, db)
- **Database Changes:** Minor schema additions
- **Testing Effort:** ~10-15 unit tests required
- **Time Estimate:** 3-4 hours development + 1 hour testing

### Complexity Factors
- **Low Complexity:** Well-defined async patterns in existing codebase
- **Medium Complexity:** Background scheduling, event integration
- **No High Complexity:** No major architectural changes required

## Dependencies

### New Dependencies
```toml
# crates/orchestrator/Cargo.toml
[dependencies]
tokio-cron-scheduler = "0.10"
```

### Environment Variables
```bash
IDLE_SESSION_TIMEOUT_MINUTES=60
IDLE_TASK_TIMEOUT_MINUTES=120
IDLE_CHECK_INTERVAL_SECONDS=30
IDLE_AUTO_TIMEOUT_ENABLED=false
```

## Success Criteria

1. **Functional**
   - ✅ Detect sessions idle > threshold
   - ✅ Detect tasks idle > threshold
   - ✅ Emit appropriate events
   - ✅ API endpoints respond correctly
   - ✅ Background scheduler runs reliably

2. **Performance**
   - ✅ Idle checks complete in <100ms
   - ✅ No more than 5% CPU overhead
   - ✅ Database queries use appropriate indexes

3. **Integration**
   - ✅ All existing tests pass
   - ✅ No clippy warnings
   - ✅ SSE events include idle notifications
   - ✅ OpenCode sessions properly tracked

## Notes

- **Assumption:** "Watch idle" means monitoring for unresponsive sessions/tasks
- **Alternative Interpretations:** Could also mean "watch when system is idle" for maintenance tasks
- **Follow-up Required:** Clarification needed on specific idle detection requirements
- **Implementation Order:** Start with monitoring/logging before implementing automatic timeouts
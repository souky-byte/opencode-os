/*
 * opencode
 *
 * opencode api
 *
 * The version of the OpenAPI document: 0.0.3
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`app_agents`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AppAgentsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`app_log`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AppLogError {
    Status400(models::BadRequestError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`auth_set`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthSetError {
    Status400(models::BadRequestError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`command_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CommandListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`config_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConfigGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`config_providers`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConfigProvidersError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`config_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConfigUpdateError {
    Status400(models::BadRequestError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`event_subscribe`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EventSubscribeError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`file_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FileListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`file_read`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FileReadError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`file_status`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FileStatusError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`find_files`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FindFilesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`find_symbols`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FindSymbolsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`find_text`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FindTextError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`formatter_status`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FormatterStatusError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`global_dispose`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GlobalDisposeError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`global_event`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GlobalEventError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`global_health`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GlobalHealthError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`instance_dispose`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum InstanceDisposeError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`lsp_status`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LspStatusError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`mcp_add`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum McpAddError {
    Status400(models::BadRequestError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`mcp_auth_authenticate`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum McpAuthAuthenticateError {
    Status400(models::BadRequestError),
    Status404(models::NotFoundError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`mcp_auth_callback`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum McpAuthCallbackError {
    Status400(models::BadRequestError),
    Status404(models::NotFoundError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`mcp_auth_remove`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum McpAuthRemoveError {
    Status404(models::NotFoundError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`mcp_auth_start`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum McpAuthStartError {
    Status400(models::BadRequestError),
    Status404(models::NotFoundError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`mcp_connect`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum McpConnectError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`mcp_disconnect`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum McpDisconnectError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`mcp_status`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum McpStatusError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`part_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PartDeleteError {
    Status400(models::BadRequestError),
    Status404(models::NotFoundError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`part_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PartUpdateError {
    Status400(models::BadRequestError),
    Status404(models::NotFoundError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`path_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PathGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`permission_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PermissionListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`permission_respond`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PermissionRespondError {
    Status400(models::BadRequestError),
    Status404(models::NotFoundError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`project_current`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectCurrentError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`project_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`project_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProjectUpdateError {
    Status400(models::BadRequestError),
    Status404(models::NotFoundError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`provider_auth`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProviderAuthError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`provider_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProviderListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`provider_oauth_authorize`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProviderOauthAuthorizeError {
    Status400(models::BadRequestError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`provider_oauth_callback`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProviderOauthCallbackError {
    Status400(models::BadRequestError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pty_connect`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PtyConnectError {
    Status404(models::NotFoundError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pty_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PtyCreateError {
    Status400(models::BadRequestError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pty_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PtyGetError {
    Status404(models::NotFoundError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pty_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PtyListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pty_remove`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PtyRemoveError {
    Status404(models::NotFoundError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pty_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PtyUpdateError {
    Status400(models::BadRequestError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`session_abort`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SessionAbortError {
    Status400(models::BadRequestError),
    Status404(models::NotFoundError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`session_command`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SessionCommandError {
    Status400(models::BadRequestError),
    Status404(models::NotFoundError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`session_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SessionCreateError {
    Status400(models::BadRequestError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`session_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SessionDeleteError {
    Status400(models::BadRequestError),
    Status404(models::NotFoundError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`session_diff`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SessionDiffError {
    Status400(models::BadRequestError),
    Status404(models::NotFoundError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`session_fork`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SessionForkError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`session_init`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SessionInitError {
    Status400(models::BadRequestError),
    Status404(models::NotFoundError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`session_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SessionListError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`session_message`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SessionMessageError {
    Status400(models::BadRequestError),
    Status404(models::NotFoundError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`session_messages`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SessionMessagesError {
    Status400(models::BadRequestError),
    Status404(models::NotFoundError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`session_prompt`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SessionPromptError {
    Status400(models::BadRequestError),
    Status404(models::NotFoundError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`session_prompt_async`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SessionPromptAsyncError {
    Status400(models::BadRequestError),
    Status404(models::NotFoundError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`session_revert`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SessionRevertError {
    Status400(models::BadRequestError),
    Status404(models::NotFoundError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`session_share`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SessionShareError {
    Status400(models::BadRequestError),
    Status404(models::NotFoundError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`session_shell`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SessionShellError {
    Status400(models::BadRequestError),
    Status404(models::NotFoundError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`session_status`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SessionStatusError {
    Status400(models::BadRequestError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`session_summarize`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SessionSummarizeError {
    Status400(models::BadRequestError),
    Status404(models::NotFoundError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`session_todo`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SessionTodoError {
    Status400(models::BadRequestError),
    Status404(models::NotFoundError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`session_unrevert`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SessionUnrevertError {
    Status400(models::BadRequestError),
    Status404(models::NotFoundError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`session_unshare`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SessionUnshareError {
    Status400(models::BadRequestError),
    Status404(models::NotFoundError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`session_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SessionUpdateError {
    Status400(models::BadRequestError),
    Status404(models::NotFoundError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tool_ids`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ToolIdsError {
    Status400(models::BadRequestError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tool_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ToolListError {
    Status400(models::BadRequestError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tui_append_prompt`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TuiAppendPromptError {
    Status400(models::BadRequestError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tui_clear_prompt`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TuiClearPromptError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tui_control_next`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TuiControlNextError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tui_control_response`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TuiControlResponseError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tui_execute_command`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TuiExecuteCommandError {
    Status400(models::BadRequestError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tui_open_help`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TuiOpenHelpError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tui_open_models`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TuiOpenModelsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tui_open_sessions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TuiOpenSessionsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tui_open_themes`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TuiOpenThemesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tui_publish`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TuiPublishError {
    Status400(models::BadRequestError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tui_show_toast`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TuiShowToastError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`tui_submit_prompt`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TuiSubmitPromptError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`vcs_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VcsGetError {
    UnknownValue(serde_json::Value),
}


/// Get a list of all available AI agents in the OpenCode system.
pub async fn app_agents(configuration: &configuration::Configuration, directory: Option<&str>) -> Result<Vec<models::Agent>, Error<AppAgentsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_directory = directory;

    let uri_str = format!("{}/agent", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Agent&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Agent&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AppAgentsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Write a log entry to the server logs with specified level and metadata.
pub async fn app_log(configuration: &configuration::Configuration, directory: Option<&str>, app_log_request: Option<models::AppLogRequest>) -> Result<bool, Error<AppLogError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_directory = directory;
    let p_body_app_log_request = app_log_request;

    let uri_str = format!("{}/log", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_app_log_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `bool`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `bool`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AppLogError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Set authentication credentials
pub async fn auth_set(configuration: &configuration::Configuration, provider_id: &str, directory: Option<&str>, auth: Option<models::Auth>) -> Result<bool, Error<AuthSetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_provider_id = provider_id;
    let p_query_directory = directory;
    let p_body_auth = auth;

    let uri_str = format!("{}/auth/{providerID}", configuration.base_path, providerID=crate::apis::urlencode(p_path_provider_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref param_value) = p_query_directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_auth);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `bool`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `bool`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AuthSetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a list of all available commands in the OpenCode system.
pub async fn command_list(configuration: &configuration::Configuration, directory: Option<&str>) -> Result<Vec<models::Command>, Error<CommandListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_directory = directory;

    let uri_str = format!("{}/command", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Command&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Command&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CommandListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve the current OpenCode configuration settings and preferences.
pub async fn config_get(configuration: &configuration::Configuration, directory: Option<&str>) -> Result<models::Config, Error<ConfigGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_directory = directory;

    let uri_str = format!("{}/config", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Config`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Config`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ConfigGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a list of all configured AI providers and their default models.
pub async fn config_providers(configuration: &configuration::Configuration, directory: Option<&str>) -> Result<models::ConfigProviders200Response, Error<ConfigProvidersError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_directory = directory;

    let uri_str = format!("{}/config/providers", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ConfigProviders200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ConfigProviders200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ConfigProvidersError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update OpenCode configuration settings and preferences.
pub async fn config_update(configuration: &configuration::Configuration, directory: Option<&str>, config: Option<models::Config>) -> Result<models::Config, Error<ConfigUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_directory = directory;
    let p_body_config = config;

    let uri_str = format!("{}/config", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref param_value) = p_query_directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_config);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Config`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Config`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ConfigUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get events
pub async fn event_subscribe(configuration: &configuration::Configuration, directory: Option<&str>) -> Result<models::Event, Error<EventSubscribeError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_directory = directory;

    let uri_str = format!("{}/event", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Event`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Event`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EventSubscribeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// List files and directories in a specified path.
pub async fn file_list(configuration: &configuration::Configuration, path: &str, directory: Option<&str>) -> Result<Vec<models::FileNode>, Error<FileListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_path = path;
    let p_query_directory = directory;

    let uri_str = format!("{}/file", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("path", &p_query_path.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::FileNode&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::FileNode&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<FileListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Read the content of a specified file.
pub async fn file_read(configuration: &configuration::Configuration, path: &str, directory: Option<&str>) -> Result<models::FileContent, Error<FileReadError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_path = path;
    let p_query_directory = directory;

    let uri_str = format!("{}/file/content", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("path", &p_query_path.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::FileContent`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::FileContent`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<FileReadError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the git status of all files in the project.
pub async fn file_status(configuration: &configuration::Configuration, directory: Option<&str>) -> Result<Vec<models::File>, Error<FileStatusError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_directory = directory;

    let uri_str = format!("{}/file/status", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::File&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::File&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<FileStatusError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Search for files or directories by name or pattern in the project directory.
pub async fn find_files(configuration: &configuration::Configuration, query: &str, directory: Option<&str>, dirs: Option<&str>, r#type: Option<&str>, limit: Option<i32>) -> Result<Vec<String>, Error<FindFilesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_query = query;
    let p_query_directory = directory;
    let p_query_dirs = dirs;
    let p_query_type = r#type;
    let p_query_limit = limit;

    let uri_str = format!("{}/find/file", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("query", &p_query_query.to_string())]);
    if let Some(ref param_value) = p_query_dirs {
        req_builder = req_builder.query(&[("dirs", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;String&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;String&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<FindFilesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Search for workspace symbols like functions, classes, and variables using LSP.
pub async fn find_symbols(configuration: &configuration::Configuration, query: &str, directory: Option<&str>) -> Result<Vec<models::Symbol>, Error<FindSymbolsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_query = query;
    let p_query_directory = directory;

    let uri_str = format!("{}/find/symbol", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("query", &p_query_query.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Symbol&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Symbol&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<FindSymbolsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Search for text patterns across files in the project using ripgrep.
pub async fn find_text(configuration: &configuration::Configuration, pattern: &str, directory: Option<&str>) -> Result<Vec<models::FindText200ResponseInner>, Error<FindTextError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_pattern = pattern;
    let p_query_directory = directory;

    let uri_str = format!("{}/find", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("pattern", &p_query_pattern.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::FindText200ResponseInner&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::FindText200ResponseInner&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<FindTextError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get formatter status
pub async fn formatter_status(configuration: &configuration::Configuration, directory: Option<&str>) -> Result<Vec<models::FormatterStatus>, Error<FormatterStatusError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_directory = directory;

    let uri_str = format!("{}/formatter", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::FormatterStatus&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::FormatterStatus&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<FormatterStatusError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Clean up and dispose all OpenCode instances, releasing all resources.
pub async fn global_dispose(configuration: &configuration::Configuration, ) -> Result<bool, Error<GlobalDisposeError>> {

    let uri_str = format!("{}/global/dispose", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `bool`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `bool`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GlobalDisposeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Subscribe to global events from the OpenCode system using server-sent events.
pub async fn global_event(configuration: &configuration::Configuration, ) -> Result<models::GlobalEvent, Error<GlobalEventError>> {

    let uri_str = format!("{}/global/event", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GlobalEvent`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GlobalEvent`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GlobalEventError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get health information about the OpenCode server.
pub async fn global_health(configuration: &configuration::Configuration, ) -> Result<models::GlobalHealth200Response, Error<GlobalHealthError>> {

    let uri_str = format!("{}/global/health", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GlobalHealth200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GlobalHealth200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GlobalHealthError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Clean up and dispose the current OpenCode instance, releasing all resources.
pub async fn instance_dispose(configuration: &configuration::Configuration, directory: Option<&str>) -> Result<bool, Error<InstanceDisposeError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_directory = directory;

    let uri_str = format!("{}/instance/dispose", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `bool`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `bool`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<InstanceDisposeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get LSP server status
pub async fn lsp_status(configuration: &configuration::Configuration, directory: Option<&str>) -> Result<Vec<models::LspStatus>, Error<LspStatusError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_directory = directory;

    let uri_str = format!("{}/lsp", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::LspStatus&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::LspStatus&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<LspStatusError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Dynamically add a new Model Context Protocol (MCP) server to the system.
pub async fn mcp_add(configuration: &configuration::Configuration, directory: Option<&str>, mcp_add_request: Option<models::McpAddRequest>) -> Result<std::collections::HashMap<String, models::McpStatus>, Error<McpAddError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_directory = directory;
    let p_body_mcp_add_request = mcp_add_request;

    let uri_str = format!("{}/mcp", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_mcp_add_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `std::collections::HashMap&lt;String, models::McpStatus&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `std::collections::HashMap&lt;String, models::McpStatus&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<McpAddError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Start OAuth flow and wait for callback (opens browser)
pub async fn mcp_auth_authenticate(configuration: &configuration::Configuration, name: &str, directory: Option<&str>) -> Result<models::McpStatus, Error<McpAuthAuthenticateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_query_directory = directory;

    let uri_str = format!("{}/mcp/{name}/auth/authenticate", configuration.base_path, name=crate::apis::urlencode(p_path_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::McpStatus`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::McpStatus`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<McpAuthAuthenticateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Complete OAuth authentication for a Model Context Protocol (MCP) server using the authorization code.
pub async fn mcp_auth_callback(configuration: &configuration::Configuration, name: &str, directory: Option<&str>, mcp_auth_callback_request: Option<models::McpAuthCallbackRequest>) -> Result<models::McpStatus, Error<McpAuthCallbackError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_query_directory = directory;
    let p_body_mcp_auth_callback_request = mcp_auth_callback_request;

    let uri_str = format!("{}/mcp/{name}/auth/callback", configuration.base_path, name=crate::apis::urlencode(p_path_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_mcp_auth_callback_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::McpStatus`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::McpStatus`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<McpAuthCallbackError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Remove OAuth credentials for an MCP server
pub async fn mcp_auth_remove(configuration: &configuration::Configuration, name: &str, directory: Option<&str>) -> Result<models::McpAuthRemove200Response, Error<McpAuthRemoveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_query_directory = directory;

    let uri_str = format!("{}/mcp/{name}/auth", configuration.base_path, name=crate::apis::urlencode(p_path_name));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref param_value) = p_query_directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::McpAuthRemove200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::McpAuthRemove200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<McpAuthRemoveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Start OAuth authentication flow for a Model Context Protocol (MCP) server.
pub async fn mcp_auth_start(configuration: &configuration::Configuration, name: &str, directory: Option<&str>) -> Result<models::McpAuthStart200Response, Error<McpAuthStartError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_query_directory = directory;

    let uri_str = format!("{}/mcp/{name}/auth", configuration.base_path, name=crate::apis::urlencode(p_path_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::McpAuthStart200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::McpAuthStart200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<McpAuthStartError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Connect an MCP server
pub async fn mcp_connect(configuration: &configuration::Configuration, name: &str, directory: Option<&str>) -> Result<bool, Error<McpConnectError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_query_directory = directory;

    let uri_str = format!("{}/mcp/{name}/connect", configuration.base_path, name=crate::apis::urlencode(p_path_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `bool`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `bool`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<McpConnectError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Disconnect an MCP server
pub async fn mcp_disconnect(configuration: &configuration::Configuration, name: &str, directory: Option<&str>) -> Result<bool, Error<McpDisconnectError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_query_directory = directory;

    let uri_str = format!("{}/mcp/{name}/disconnect", configuration.base_path, name=crate::apis::urlencode(p_path_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `bool`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `bool`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<McpDisconnectError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get the status of all Model Context Protocol (MCP) servers.
pub async fn mcp_status(configuration: &configuration::Configuration, directory: Option<&str>) -> Result<std::collections::HashMap<String, models::McpStatus>, Error<McpStatusError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_directory = directory;

    let uri_str = format!("{}/mcp", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `std::collections::HashMap&lt;String, models::McpStatus&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `std::collections::HashMap&lt;String, models::McpStatus&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<McpStatusError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Delete a part from a message
pub async fn part_delete(configuration: &configuration::Configuration, session_id: &str, message_id: &str, part_id: &str, directory: Option<&str>) -> Result<bool, Error<PartDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_session_id = session_id;
    let p_path_message_id = message_id;
    let p_path_part_id = part_id;
    let p_query_directory = directory;

    let uri_str = format!("{}/session/{sessionID}/message/{messageID}/part/{partID}", configuration.base_path, sessionID=crate::apis::urlencode(p_path_session_id), messageID=crate::apis::urlencode(p_path_message_id), partID=crate::apis::urlencode(p_path_part_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref param_value) = p_query_directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `bool`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `bool`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PartDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update a part in a message
pub async fn part_update(configuration: &configuration::Configuration, session_id: &str, message_id: &str, part_id: &str, directory: Option<&str>, part: Option<models::Part>) -> Result<models::Part, Error<PartUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_session_id = session_id;
    let p_path_message_id = message_id;
    let p_path_part_id = part_id;
    let p_query_directory = directory;
    let p_body_part = part;

    let uri_str = format!("{}/session/{sessionID}/message/{messageID}/part/{partID}", configuration.base_path, sessionID=crate::apis::urlencode(p_path_session_id), messageID=crate::apis::urlencode(p_path_message_id), partID=crate::apis::urlencode(p_path_part_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref param_value) = p_query_directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_part);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Part`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Part`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PartUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve the current working directory and related path information for the OpenCode instance.
pub async fn path_get(configuration: &configuration::Configuration, directory: Option<&str>) -> Result<models::Path, Error<PathGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_directory = directory;

    let uri_str = format!("{}/path", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Path`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Path`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PathGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get all pending permission requests across all sessions.
pub async fn permission_list(configuration: &configuration::Configuration, directory: Option<&str>) -> Result<Vec<models::Permission>, Error<PermissionListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_directory = directory;

    let uri_str = format!("{}/permission", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Permission&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Permission&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PermissionListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Approve or deny a permission request from the AI assistant.
pub async fn permission_respond(configuration: &configuration::Configuration, session_id: &str, permission_id: &str, directory: Option<&str>, permission_respond_request: Option<models::PermissionRespondRequest>) -> Result<bool, Error<PermissionRespondError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_session_id = session_id;
    let p_path_permission_id = permission_id;
    let p_query_directory = directory;
    let p_body_permission_respond_request = permission_respond_request;

    let uri_str = format!("{}/session/{sessionID}/permissions/{permissionID}", configuration.base_path, sessionID=crate::apis::urlencode(p_path_session_id), permissionID=crate::apis::urlencode(p_path_permission_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_permission_respond_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `bool`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `bool`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PermissionRespondError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve the currently active project that OpenCode is working with.
pub async fn project_current(configuration: &configuration::Configuration, directory: Option<&str>) -> Result<models::Project, Error<ProjectCurrentError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_directory = directory;

    let uri_str = format!("{}/project/current", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Project`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Project`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ProjectCurrentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a list of projects that have been opened with OpenCode.
pub async fn project_list(configuration: &configuration::Configuration, directory: Option<&str>) -> Result<Vec<models::Project>, Error<ProjectListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_directory = directory;

    let uri_str = format!("{}/project", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Project&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Project&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ProjectListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update project properties such as name, icon and color.
pub async fn project_update(configuration: &configuration::Configuration, project_id: &str, directory: Option<&str>, project_update_request: Option<models::ProjectUpdateRequest>) -> Result<models::Project, Error<ProjectUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_project_id = project_id;
    let p_query_directory = directory;
    let p_body_project_update_request = project_update_request;

    let uri_str = format!("{}/project/{projectID}", configuration.base_path, projectID=crate::apis::urlencode(p_path_project_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref param_value) = p_query_directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_project_update_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Project`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Project`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ProjectUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve available authentication methods for all AI providers.
pub async fn provider_auth(configuration: &configuration::Configuration, directory: Option<&str>) -> Result<std::collections::HashMap<String, Vec<models::ProviderAuthMethod>>, Error<ProviderAuthError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_directory = directory;

    let uri_str = format!("{}/provider/auth", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `std::collections::HashMap&lt;String, Vec&lt;models::ProviderAuthMethod&gt;&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `std::collections::HashMap&lt;String, Vec&lt;models::ProviderAuthMethod&gt;&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ProviderAuthError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a list of all available AI providers, including both available and connected ones.
pub async fn provider_list(configuration: &configuration::Configuration, directory: Option<&str>) -> Result<models::ProviderList200Response, Error<ProviderListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_directory = directory;

    let uri_str = format!("{}/provider", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProviderList200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProviderList200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ProviderListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Initiate OAuth authorization for a specific AI provider to get an authorization URL.
pub async fn provider_oauth_authorize(configuration: &configuration::Configuration, provider_id: &str, directory: Option<&str>, provider_oauth_authorize_request: Option<models::ProviderOauthAuthorizeRequest>) -> Result<models::ProviderAuthAuthorization, Error<ProviderOauthAuthorizeError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_provider_id = provider_id;
    let p_query_directory = directory;
    let p_body_provider_oauth_authorize_request = provider_oauth_authorize_request;

    let uri_str = format!("{}/provider/{providerID}/oauth/authorize", configuration.base_path, providerID=crate::apis::urlencode(p_path_provider_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_provider_oauth_authorize_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ProviderAuthAuthorization`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ProviderAuthAuthorization`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ProviderOauthAuthorizeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Handle the OAuth callback from a provider after user authorization.
pub async fn provider_oauth_callback(configuration: &configuration::Configuration, provider_id: &str, directory: Option<&str>, provider_oauth_callback_request: Option<models::ProviderOauthCallbackRequest>) -> Result<bool, Error<ProviderOauthCallbackError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_provider_id = provider_id;
    let p_query_directory = directory;
    let p_body_provider_oauth_callback_request = provider_oauth_callback_request;

    let uri_str = format!("{}/provider/{providerID}/oauth/callback", configuration.base_path, providerID=crate::apis::urlencode(p_path_provider_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_provider_oauth_callback_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `bool`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `bool`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ProviderOauthCallbackError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Establish a WebSocket connection to interact with a pseudo-terminal (PTY) session in real-time.
pub async fn pty_connect(configuration: &configuration::Configuration, pty_id: &str, directory: Option<&str>) -> Result<bool, Error<PtyConnectError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_pty_id = pty_id;
    let p_query_directory = directory;

    let uri_str = format!("{}/pty/{ptyID}/connect", configuration.base_path, ptyID=crate::apis::urlencode(p_path_pty_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `bool`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `bool`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PtyConnectError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create a new pseudo-terminal (PTY) session for running shell commands and processes.
pub async fn pty_create(configuration: &configuration::Configuration, directory: Option<&str>, pty_create_request: Option<models::PtyCreateRequest>) -> Result<models::Pty, Error<PtyCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_directory = directory;
    let p_body_pty_create_request = pty_create_request;

    let uri_str = format!("{}/pty", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_pty_create_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Pty`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Pty`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PtyCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve detailed information about a specific pseudo-terminal (PTY) session.
pub async fn pty_get(configuration: &configuration::Configuration, pty_id: &str, directory: Option<&str>) -> Result<models::Pty, Error<PtyGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_pty_id = pty_id;
    let p_query_directory = directory;

    let uri_str = format!("{}/pty/{ptyID}", configuration.base_path, ptyID=crate::apis::urlencode(p_path_pty_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Pty`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Pty`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PtyGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a list of all active pseudo-terminal (PTY) sessions managed by OpenCode.
pub async fn pty_list(configuration: &configuration::Configuration, directory: Option<&str>) -> Result<Vec<models::Pty>, Error<PtyListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_directory = directory;

    let uri_str = format!("{}/pty", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Pty&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Pty&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PtyListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Remove and terminate a specific pseudo-terminal (PTY) session.
pub async fn pty_remove(configuration: &configuration::Configuration, pty_id: &str, directory: Option<&str>) -> Result<bool, Error<PtyRemoveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_pty_id = pty_id;
    let p_query_directory = directory;

    let uri_str = format!("{}/pty/{ptyID}", configuration.base_path, ptyID=crate::apis::urlencode(p_path_pty_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref param_value) = p_query_directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `bool`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `bool`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PtyRemoveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update properties of an existing pseudo-terminal (PTY) session.
pub async fn pty_update(configuration: &configuration::Configuration, pty_id: &str, directory: Option<&str>, pty_update_request: Option<models::PtyUpdateRequest>) -> Result<models::Pty, Error<PtyUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_pty_id = pty_id;
    let p_query_directory = directory;
    let p_body_pty_update_request = pty_update_request;

    let uri_str = format!("{}/pty/{ptyID}", configuration.base_path, ptyID=crate::apis::urlencode(p_path_pty_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref param_value) = p_query_directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_pty_update_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Pty`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Pty`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PtyUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Abort an active session and stop any ongoing AI processing or command execution.
pub async fn session_abort(configuration: &configuration::Configuration, session_id: &str, directory: Option<&str>) -> Result<bool, Error<SessionAbortError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_session_id = session_id;
    let p_query_directory = directory;

    let uri_str = format!("{}/session/{sessionID}/abort", configuration.base_path, sessionID=crate::apis::urlencode(p_path_session_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `bool`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `bool`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SessionAbortError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Send a new command to a session for execution by the AI assistant.
pub async fn session_command(configuration: &configuration::Configuration, session_id: &str, directory: Option<&str>, session_command_request: Option<models::SessionCommandRequest>) -> Result<models::SessionPrompt200Response, Error<SessionCommandError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_session_id = session_id;
    let p_query_directory = directory;
    let p_body_session_command_request = session_command_request;

    let uri_str = format!("{}/session/{sessionID}/command", configuration.base_path, sessionID=crate::apis::urlencode(p_path_session_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_session_command_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SessionPrompt200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SessionPrompt200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SessionCommandError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create a new OpenCode session for interacting with AI assistants and managing conversations.
pub async fn session_create(configuration: &configuration::Configuration, directory: Option<&str>, session_create_request: Option<models::SessionCreateRequest>) -> Result<models::Session, Error<SessionCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_directory = directory;
    let p_body_session_create_request = session_create_request;

    let uri_str = format!("{}/session", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_session_create_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Session`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Session`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SessionCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Delete a session and permanently remove all associated data, including messages and history.
pub async fn session_delete(configuration: &configuration::Configuration, session_id: &str, directory: Option<&str>) -> Result<bool, Error<SessionDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_session_id = session_id;
    let p_query_directory = directory;

    let uri_str = format!("{}/session/{sessionID}", configuration.base_path, sessionID=crate::apis::urlencode(p_path_session_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref param_value) = p_query_directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `bool`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `bool`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SessionDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get all file changes (diffs) made during this session.
pub async fn session_diff(configuration: &configuration::Configuration, session_id: &str, directory: Option<&str>, message_id: Option<&str>) -> Result<Vec<models::FileDiff>, Error<SessionDiffError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_session_id = session_id;
    let p_query_directory = directory;
    let p_query_message_id = message_id;

    let uri_str = format!("{}/session/{sessionID}/diff", configuration.base_path, sessionID=crate::apis::urlencode(p_path_session_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_message_id {
        req_builder = req_builder.query(&[("messageID", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::FileDiff&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::FileDiff&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SessionDiffError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create a new session by forking an existing session at a specific message point.
pub async fn session_fork(configuration: &configuration::Configuration, session_id: &str, directory: Option<&str>, session_fork_request: Option<models::SessionForkRequest>) -> Result<models::Session, Error<SessionForkError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_session_id = session_id;
    let p_query_directory = directory;
    let p_body_session_fork_request = session_fork_request;

    let uri_str = format!("{}/session/{sessionID}/fork", configuration.base_path, sessionID=crate::apis::urlencode(p_path_session_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_session_fork_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Session`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Session`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SessionForkError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Analyze the current application and create an AGENTS.md file with project-specific agent configurations.
pub async fn session_init(configuration: &configuration::Configuration, session_id: &str, directory: Option<&str>, session_init_request: Option<models::SessionInitRequest>) -> Result<bool, Error<SessionInitError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_session_id = session_id;
    let p_query_directory = directory;
    let p_body_session_init_request = session_init_request;

    let uri_str = format!("{}/session/{sessionID}/init", configuration.base_path, sessionID=crate::apis::urlencode(p_path_session_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_session_init_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `bool`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `bool`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SessionInitError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a list of all OpenCode sessions, sorted by most recently updated.
pub async fn session_list(configuration: &configuration::Configuration, directory: Option<&str>) -> Result<Vec<models::Session>, Error<SessionListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_directory = directory;

    let uri_str = format!("{}/session", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Session&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Session&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SessionListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve a specific message from a session by its message ID.
pub async fn session_message(configuration: &configuration::Configuration, session_id: &str, message_id: &str, directory: Option<&str>) -> Result<models::SessionMessages200ResponseInner, Error<SessionMessageError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_session_id = session_id;
    let p_path_message_id = message_id;
    let p_query_directory = directory;

    let uri_str = format!("{}/session/{sessionID}/message/{messageID}", configuration.base_path, sessionID=crate::apis::urlencode(p_path_session_id), messageID=crate::apis::urlencode(p_path_message_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SessionMessages200ResponseInner`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SessionMessages200ResponseInner`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SessionMessageError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve all messages in a session, including user prompts and AI responses.
pub async fn session_messages(configuration: &configuration::Configuration, session_id: &str, directory: Option<&str>, limit: Option<f64>) -> Result<Vec<models::SessionMessages200ResponseInner>, Error<SessionMessagesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_session_id = session_id;
    let p_query_directory = directory;
    let p_query_limit = limit;

    let uri_str = format!("{}/session/{sessionID}/message", configuration.base_path, sessionID=crate::apis::urlencode(p_path_session_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::SessionMessages200ResponseInner&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::SessionMessages200ResponseInner&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SessionMessagesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create and send a new message to a session, streaming the AI response.
pub async fn session_prompt(configuration: &configuration::Configuration, session_id: &str, directory: Option<&str>, session_prompt_request: Option<models::SessionPromptRequest>) -> Result<models::SessionPrompt200Response, Error<SessionPromptError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_session_id = session_id;
    let p_query_directory = directory;
    let p_body_session_prompt_request = session_prompt_request;

    let uri_str = format!("{}/session/{sessionID}/message", configuration.base_path, sessionID=crate::apis::urlencode(p_path_session_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_session_prompt_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SessionPrompt200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SessionPrompt200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SessionPromptError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create and send a new message to a session asynchronously, starting the session if needed and returning immediately.
pub async fn session_prompt_async(configuration: &configuration::Configuration, session_id: &str, directory: Option<&str>, session_prompt_request: Option<models::SessionPromptRequest>) -> Result<(), Error<SessionPromptAsyncError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_session_id = session_id;
    let p_query_directory = directory;
    let p_body_session_prompt_request = session_prompt_request;

    let uri_str = format!("{}/session/{sessionID}/prompt_async", configuration.base_path, sessionID=crate::apis::urlencode(p_path_session_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_session_prompt_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<SessionPromptAsyncError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Revert a specific message in a session, undoing its effects and restoring the previous state.
pub async fn session_revert(configuration: &configuration::Configuration, session_id: &str, directory: Option<&str>, session_revert_request: Option<models::SessionRevertRequest>) -> Result<models::Session, Error<SessionRevertError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_session_id = session_id;
    let p_query_directory = directory;
    let p_body_session_revert_request = session_revert_request;

    let uri_str = format!("{}/session/{sessionID}/revert", configuration.base_path, sessionID=crate::apis::urlencode(p_path_session_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_session_revert_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Session`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Session`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SessionRevertError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create a shareable link for a session, allowing others to view the conversation.
pub async fn session_share(configuration: &configuration::Configuration, session_id: &str, directory: Option<&str>) -> Result<models::Session, Error<SessionShareError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_session_id = session_id;
    let p_query_directory = directory;

    let uri_str = format!("{}/session/{sessionID}/share", configuration.base_path, sessionID=crate::apis::urlencode(p_path_session_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Session`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Session`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SessionShareError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Execute a shell command within the session context and return the AI's response.
pub async fn session_shell(configuration: &configuration::Configuration, session_id: &str, directory: Option<&str>, session_shell_request: Option<models::SessionShellRequest>) -> Result<models::AssistantMessage, Error<SessionShellError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_session_id = session_id;
    let p_query_directory = directory;
    let p_body_session_shell_request = session_shell_request;

    let uri_str = format!("{}/session/{sessionID}/shell", configuration.base_path, sessionID=crate::apis::urlencode(p_path_session_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_session_shell_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AssistantMessage`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AssistantMessage`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SessionShellError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve the current status of all sessions, including active, idle, and completed states.
pub async fn session_status(configuration: &configuration::Configuration, directory: Option<&str>) -> Result<std::collections::HashMap<String, models::SessionStatus>, Error<SessionStatusError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_directory = directory;

    let uri_str = format!("{}/session/status", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `std::collections::HashMap&lt;String, models::SessionStatus&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `std::collections::HashMap&lt;String, models::SessionStatus&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SessionStatusError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Generate a concise summary of the session using AI compaction to preserve key information.
pub async fn session_summarize(configuration: &configuration::Configuration, session_id: &str, directory: Option<&str>, session_summarize_request: Option<models::SessionSummarizeRequest>) -> Result<bool, Error<SessionSummarizeError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_session_id = session_id;
    let p_query_directory = directory;
    let p_body_session_summarize_request = session_summarize_request;

    let uri_str = format!("{}/session/{sessionID}/summarize", configuration.base_path, sessionID=crate::apis::urlencode(p_path_session_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_session_summarize_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `bool`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `bool`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SessionSummarizeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve the todo list associated with a specific session, showing tasks and action items.
pub async fn session_todo(configuration: &configuration::Configuration, session_id: &str, directory: Option<&str>) -> Result<Vec<models::Todo>, Error<SessionTodoError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_session_id = session_id;
    let p_query_directory = directory;

    let uri_str = format!("{}/session/{sessionID}/todo", configuration.base_path, sessionID=crate::apis::urlencode(p_path_session_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Todo&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Todo&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SessionTodoError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Restore all previously reverted messages in a session.
pub async fn session_unrevert(configuration: &configuration::Configuration, session_id: &str, directory: Option<&str>) -> Result<models::Session, Error<SessionUnrevertError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_session_id = session_id;
    let p_query_directory = directory;

    let uri_str = format!("{}/session/{sessionID}/unrevert", configuration.base_path, sessionID=crate::apis::urlencode(p_path_session_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Session`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Session`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SessionUnrevertError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Remove the shareable link for a session, making it private again.
pub async fn session_unshare(configuration: &configuration::Configuration, session_id: &str, directory: Option<&str>) -> Result<models::Session, Error<SessionUnshareError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_session_id = session_id;
    let p_query_directory = directory;

    let uri_str = format!("{}/session/{sessionID}/share", configuration.base_path, sessionID=crate::apis::urlencode(p_path_session_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref param_value) = p_query_directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Session`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Session`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SessionUnshareError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update properties of an existing session, such as title or other metadata.
pub async fn session_update(configuration: &configuration::Configuration, session_id: &str, directory: Option<&str>, session_update_request: Option<models::SessionUpdateRequest>) -> Result<models::Session, Error<SessionUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_session_id = session_id;
    let p_query_directory = directory;
    let p_body_session_update_request = session_update_request;

    let uri_str = format!("{}/session/{sessionID}", configuration.base_path, sessionID=crate::apis::urlencode(p_path_session_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref param_value) = p_query_directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_session_update_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Session`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Session`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SessionUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a list of all available tool IDs, including both built-in tools and dynamically registered tools.
pub async fn tool_ids(configuration: &configuration::Configuration, directory: Option<&str>) -> Result<Vec<String>, Error<ToolIdsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_directory = directory;

    let uri_str = format!("{}/experimental/tool/ids", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;String&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;String&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ToolIdsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get a list of available tools with their JSON schema parameters for a specific provider and model combination.
pub async fn tool_list(configuration: &configuration::Configuration, provider: &str, model: &str, directory: Option<&str>) -> Result<Vec<models::ToolListItem>, Error<ToolListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_provider = provider;
    let p_query_model = model;
    let p_query_directory = directory;

    let uri_str = format!("{}/experimental/tool", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("provider", &p_query_provider.to_string())]);
    req_builder = req_builder.query(&[("model", &p_query_model.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::ToolListItem&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::ToolListItem&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ToolListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Append prompt to the TUI
pub async fn tui_append_prompt(configuration: &configuration::Configuration, directory: Option<&str>, find_text200_response_inner_path: Option<models::FindText200ResponseInnerPath>) -> Result<bool, Error<TuiAppendPromptError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_directory = directory;
    let p_body_find_text200_response_inner_path = find_text200_response_inner_path;

    let uri_str = format!("{}/tui/append-prompt", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_find_text200_response_inner_path);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `bool`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `bool`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TuiAppendPromptError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Clear the prompt
pub async fn tui_clear_prompt(configuration: &configuration::Configuration, directory: Option<&str>) -> Result<bool, Error<TuiClearPromptError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_directory = directory;

    let uri_str = format!("{}/tui/clear-prompt", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `bool`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `bool`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TuiClearPromptError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve the next TUI (Terminal User Interface) request from the queue for processing.
pub async fn tui_control_next(configuration: &configuration::Configuration, directory: Option<&str>) -> Result<models::TuiControlNext200Response, Error<TuiControlNextError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_directory = directory;

    let uri_str = format!("{}/tui/control/next", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TuiControlNext200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TuiControlNext200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TuiControlNextError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Submit a response to the TUI request queue to complete a pending request.
pub async fn tui_control_response(configuration: &configuration::Configuration, directory: Option<&str>, body: Option<serde_json::Value>) -> Result<bool, Error<TuiControlResponseError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_directory = directory;
    let p_body_body = body;

    let uri_str = format!("{}/tui/control/response", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `bool`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `bool`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TuiControlResponseError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Execute a TUI command (e.g. agent_cycle)
pub async fn tui_execute_command(configuration: &configuration::Configuration, directory: Option<&str>, tui_execute_command_request: Option<models::TuiExecuteCommandRequest>) -> Result<bool, Error<TuiExecuteCommandError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_directory = directory;
    let p_body_tui_execute_command_request = tui_execute_command_request;

    let uri_str = format!("{}/tui/execute-command", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_tui_execute_command_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `bool`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `bool`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TuiExecuteCommandError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Open the help dialog in the TUI to display user assistance information.
pub async fn tui_open_help(configuration: &configuration::Configuration, directory: Option<&str>) -> Result<bool, Error<TuiOpenHelpError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_directory = directory;

    let uri_str = format!("{}/tui/open-help", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `bool`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `bool`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TuiOpenHelpError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Open the model dialog
pub async fn tui_open_models(configuration: &configuration::Configuration, directory: Option<&str>) -> Result<bool, Error<TuiOpenModelsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_directory = directory;

    let uri_str = format!("{}/tui/open-models", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `bool`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `bool`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TuiOpenModelsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Open the session dialog
pub async fn tui_open_sessions(configuration: &configuration::Configuration, directory: Option<&str>) -> Result<bool, Error<TuiOpenSessionsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_directory = directory;

    let uri_str = format!("{}/tui/open-sessions", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `bool`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `bool`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TuiOpenSessionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Open the theme dialog
pub async fn tui_open_themes(configuration: &configuration::Configuration, directory: Option<&str>) -> Result<bool, Error<TuiOpenThemesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_directory = directory;

    let uri_str = format!("{}/tui/open-themes", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `bool`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `bool`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TuiOpenThemesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Publish a TUI event
pub async fn tui_publish(configuration: &configuration::Configuration, directory: Option<&str>, tui_publish_request: Option<models::TuiPublishRequest>) -> Result<bool, Error<TuiPublishError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_directory = directory;
    let p_body_tui_publish_request = tui_publish_request;

    let uri_str = format!("{}/tui/publish", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_tui_publish_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `bool`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `bool`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TuiPublishError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Show a toast notification in the TUI
pub async fn tui_show_toast(configuration: &configuration::Configuration, directory: Option<&str>, tui_show_toast_request: Option<models::TuiShowToastRequest>) -> Result<bool, Error<TuiShowToastError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_directory = directory;
    let p_body_tui_show_toast_request = tui_show_toast_request;

    let uri_str = format!("{}/tui/show-toast", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_tui_show_toast_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `bool`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `bool`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TuiShowToastError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Submit the prompt
pub async fn tui_submit_prompt(configuration: &configuration::Configuration, directory: Option<&str>) -> Result<bool, Error<TuiSubmitPromptError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_directory = directory;

    let uri_str = format!("{}/tui/submit-prompt", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `bool`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `bool`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TuiSubmitPromptError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve version control system (VCS) information for the current project, such as git branch.
pub async fn vcs_get(configuration: &configuration::Configuration, directory: Option<&str>) -> Result<models::VcsInfo, Error<VcsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_directory = directory;

    let uri_str = format!("{}/vcs", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_directory {
        req_builder = req_builder.query(&[("directory", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::VcsInfo`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::VcsInfo`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<VcsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

